
# https://lens.xyz/docs/protocol llms-full.txt

## Lens Social Protocol
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Lens Social Protocol

Add SocialFi features to any application.

The Lens Social Protocol is a collection of primitives designed to streamline development of SocialFi applications. They include the Social Primitives (Accounts, Usernames, Graphs, Groups, Feeds), Apps, Rules, Actions and Sponsorships.

Lens offers a highly customisable set of powerful Social Primitives developers can choose from. The Lens architecture has been streamlined to make integrating Social Primitives easy and flexible. Developers can build experiences with easy-to-plug-in “Social Legos.” Social Primitives are modular, enabling developers to create custom instances tailored to their needs. These core contracts can be modified with Rules and Actions. Apps and Sponsorships allow for easy management and customization for application builders.

[Next\\
\\
**Concepts**](https://lens.xyz/docs/protocol/concepts/account)

## Graph in Lens Protocol
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

simone@13,000Followers•932Followingsimonefoodie@1,232Followers•212Followingsimonescakes@4,526Followers•59Following

# Graph

The Graph represents the network of connections between accounts, such as follows and unfollows, within the Lens protocol.
Both global and app-level graphs can be deployed as onchain contracts, allowing applications to build and manage their own audience.
This enables apps to create tailored social experiences, defining how users interact within their platform.

Administrators can add custom rules to their graphs using the modular rule system.
For example, they might require users to own a specific NFT to establish connections within the graph.
Metadata settings help describe the graph's purpose and context. Additionally, accounts can set personal graph rules, adding another layer of
customization and control over their social interactions.

[Previous\\
\\
**Username**](https://lens.xyz/docs/protocol/concepts/username) [Next\\
\\
**Rules**](https://lens.xyz/docs/protocol/concepts/rules)

## Lens Protocol Contracts
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Lens Contracts

This page list useful resources for interacting with the Lens Protocol smart contracts.

## Deployed Contracts

The Lens protocol smart contracts are deployed at the following addresses on the corresponding networks.

### Lens Mainnet

| **Factories** | **Address** |  |
| --- | --- | --- |
| [AccessControlFactory](https://explorer.lens.xyz/address/0x0d028419c270C2d366929f459418a4905D1B778F) | 0x0d028419c270C2d366929f459418a4905D1B778F |  |
| [AccountFactory](https://explorer.lens.xyz/address/0x26C7fd63B06deb4F9E4B5955D540767b9Ac7bbaa) | 0x26C7fd63B06deb4F9E4B5955D540767b9Ac7bbaa |  |
| [AppFactory](https://explorer.lens.xyz/address/0xB3b7502C47E16a1E3c6d660b73006f45Ec327B0B) | 0xB3b7502C47E16a1E3c6d660b73006f45Ec327B0B |  |
| [FeedFactory](https://explorer.lens.xyz/address/0x591c6e036a6bC92C6bF0d1dB991D06E74C2B9a6A) | 0x591c6e036a6bC92C6bF0d1dB991D06E74C2B9a6A |  |
| [GraphFactory](https://explorer.lens.xyz/address/0x837E95c3A69Cd6efa3eCDE87A3a07801AAB25Ba0) | 0x837E95c3A69Cd6efa3eCDE87A3a07801AAB25Ba0 |  |
| [GroupFactory](https://explorer.lens.xyz/address/0x9810C41e805164f30b58395b2Af976B3229b0CE6) | 0x9810C41e805164f30b58395b2Af976B3229b0CE6 |  |
| [NamespaceFactory](https://explorer.lens.xyz/address/0x3155ccbeefbA266a4B6060fB1F9d4b8591d1De3F) | 0x3155ccbeefbA266a4B6060fB1F9d4b8591d1De3F |  |
| [LensFactory](https://explorer.lens.xyz/address/0x1fa75D26819Ac733bf7B1C1B36C3F8aEF32d2Cc0) | 0x1fa75D26819Ac733bf7B1C1B36C3F8aEF32d2Cc0 |  |

| **Global Instances** | **Address** |  |
| --- | --- | --- |
| [Global Feed](https://explorer.lens.xyz/address/0xcB5E109FFC0E15565082d78E68dDDf2573703580) | 0xcB5E109FFC0E15565082d78E68dDDf2573703580 |  |
| [Global Graph](https://explorer.lens.xyz/address/0x433025d9718302E7B2e1853D712d96F00764513F) | 0x433025d9718302E7B2e1853D712d96F00764513F |  |
| [Lens Namespace](https://explorer.lens.xyz/address/0x1aA55B9042f08f45825dC4b651B64c9F98Af4615) | 0x1aA55B9042f08f45825dC4b651B64c9F98Af4615 |  |
| [Test App](https://explorer.lens.xyz/address/0x8A5Cc31180c37078e1EbA2A23c861Acf351a97cE) | 0x8A5Cc31180c37078e1EbA2A23c861Acf351a97cE |  |

| **Auxiliary** | **Address** |  |
| --- | --- | --- |
| [ActionHub](https://explorer.lens.xyz/address/0xc6d57ee750ef2ee017a9e985a0c4198bed16a802) | 0xc6d57ee750ef2ee017a9e985a0c4198bed16a802 |  |

| **Actions** | **Address** |  |
| --- | --- | --- |
| [TippingAccountAction](https://explorer.lens.xyz/address/0x20170f1e53851df4d9ea236a28399493c5b152c0) | 0x20170f1e53851df4d9ea236a28399493c5b152c0 |  |
| [TippingPostAction](https://explorer.lens.xyz/address/0x4984ec4ffd17e64c8f91691d829bd5aea287e47b) | 0x4984ec4ffd17e64c8f91691d829bd5aea287e47b |  |
| [SimpleCollectAction](https://explorer.lens.xyz/address/0x1cee1cd464c4e44e80acdb0b0e33f88849070f6e) | 0x1cee1cd464c4e44e80acdb0b0e33f88849070f6e |  |

| **Graph Rules** | Address |  |
| --- | --- | --- |
| [GroupGatedGraphRule](https://explorer.lens.xyz/address/0x754839c5917a063eb923e83f1194e6737bbb451c) | 0x754839c5917a063eb923e83f1194e6737bbb451c |  |
| [TokenGatedGraphRule](https://explorer.lens.xyz/address/0x24779f9c251cc5c2ac0ae5c9f274666224e78035) | 0x24779f9c251cc5c2ac0ae5c9f274666224e78035 |  |

| **Group Rules** | Address |  |
| --- | --- | --- |
| [BanMemberGroupRule](https://explorer.lens.xyz/address/0xe12543e5f917ada5aef92b26bc08e1925ec9f53f) | 0xe12543e5f917ada5aef92b26bc08e1925ec9f53f |  |
| [MembershipApprovalGroupRule](https://explorer.lens.xyz/address/0x353064b2ee992483398dab32267e1ad597e502b9) | 0x353064b2ee992483398dab32267e1ad597e502b9 |  |
| [SimplePaymentGroupRule](https://explorer.lens.xyz/address/0x6d2251d69fba6d7e761c72d55cf478d741cb4ac1) | 0x6d2251d69fba6d7e761c72d55cf478d741cb4ac1 |  |
| [TokenGatedGroupRule](https://explorer.lens.xyz/address/0x0740653858863e8f4f0c734553c2bef0dc54bfa9) | 0x0740653858863e8f4f0c734553c2bef0dc54bfa9 |  |

| **Feed Rules** | Address |  |
| --- | --- | --- |
| [GroupGatedFeedRule](https://explorer.lens.xyz/address/0x40a2a352583b266097234f1260b5aafb7b129047) | 0x40a2a352583b266097234f1260b5aafb7b129047 |  |
| [SimplePaymentFeedRule](https://explorer.lens.xyz/address/0xd79dfb3f8290c0da1899b91c3bbfe9ab56198004) | 0xd79dfb3f8290c0da1899b91c3bbfe9ab56198004 |  |
| [TokenGatedFeedRule](https://explorer.lens.xyz/address/0xe320d45b21243771dc5a47909db2389abab81d5b) | 0xe320d45b21243771dc5a47909db2389abab81d5b |  |

| **Namespace Rules** | Address |  |
| --- | --- | --- |
| [UsernameSimpleCharsetNamespaceRule](https://explorer.lens.xyz/address/0x5dbe2054903512ff26e336c0cbded6e0ddbeac4f) | 0x5dbe2054903512ff26e336c0cbded6e0ddbeac4f |  |
| [UsernameLengthNamespaceRule](https://explorer.lens.xyz/address/0xb541055222c87ee86a72558e8b582a9c0158a0d8) | 0xb541055222c87ee86a72558e8b582a9c0158a0d8 |  |
| [UsernameReservedNamespaceRule](https://explorer.lens.xyz/address/0x0e8b9960f2a891a561f2d52f0cd98cca19cdf8c9) | 0x0e8b9960f2a891a561f2d52f0cd98cca19cdf8c9 |  |
| [TokenGatedNamespaceRule](https://explorer.lens.xyz/address/0xd108e4215963f9cb13f47a4b08110d0ff51d52d8) | 0xd108e4215963f9cb13f47a4b08110d0ff51d52d8 |  |
| [UsernamePricePerLengthNamespaceRule](https://explorer.lens.xyz/address/0xad917a20bca258020ff81590f62ff05366ebb180) | 0xad917a20bca258020ff81590f62ff05366ebb180 |  |

| **Follow Rules** | Address |  |
| --- | --- | --- |
| [SimplePaymentFollowRule](https://explorer.lens.xyz/address/0x10e044f026bd51f855a10f2277e35ed4c896db7e) | 0x10e044f026bd51f855a10f2277e35ed4c896db7e |  |
| [TokenGatedFollowRule](https://explorer.lens.xyz/address/0x8b39e5e2b7a4ce8fcd8f4601ca1a43486a9d7ca4) | 0x8b39e5e2b7a4ce8fcd8f4601ca1a43486a9d7ca4 |  |

| **Post Rules** | Address |  |
| --- | --- | --- |
| [FollowersOnlyPostRule](https://explorer.lens.xyz/address/0x4f573ed906cf23cb43f86ad461d10e43e29802ce) | 0x4f573ed906cf23cb43f86ad461d10e43e29802ce |  |

| **Global Rules** | Address |  |
| --- | --- | --- |
| [AccountBlockingRule](https://explorer.lens.xyz/address/0x3b766408f14141f4b567681a1c29cfb58d1c1574) | 0x3b766408f14141f4b567681a1c29cfb58d1c1574 |  |

### Lens Testnet

| **Factories** | **Address** |  |
| --- | --- | --- |
| [AccessControlFactory](https://explorer.testnet.lens.xyz/address/0x5eb740362F17815Ae67EBcA6420Cbb350f714C3E) | 0x5eb740362F17815Ae67EBcA6420Cbb350f714C3E |  |
| [AccountFactory](https://explorer.testnet.lens.xyz/address/0xE55C2154d1766a9C6319dBD989C89867b0457358) | 0xE55C2154d1766a9C6319dBD989C89867b0457358 |  |
| [AppFactory](https://explorer.testnet.lens.xyz/address/0xc650f3CcfF7801F5e95a99B99AAbD2f6319d38ed) | 0xc650f3CcfF7801F5e95a99B99AAbD2f6319d38ed |  |
| [FeedFactory](https://explorer.testnet.lens.xyz/address/0xb8169FB0FaB6a699854fd4fD2457b990988E1372) | 0xb8169FB0FaB6a699854fd4fD2457b990988E1372 |  |
| [GraphFactory](https://explorer.testnet.lens.xyz/address/0x7cbB07bD2E80A27c59Ed707B79024cC5e54dEaF0) | 0x7cbB07bD2E80A27c59Ed707B79024cC5e54dEaF0 |  |
| [GroupFactory](https://explorer.testnet.lens.xyz/address/0xEF51808f8a2399282CDd156E897473b282998a29) | 0xEF51808f8a2399282CDd156E897473b282998a29 |  |
| [NamespaceFactory](https://explorer.testnet.lens.xyz/address/0xb69CBb69041a30216e2fe13E9700b32761b859C3) | 0xb69CBb69041a30216e2fe13E9700b32761b859C3 |  |
| [LensFactory](https://explorer.testnet.lens.xyz/address/0x408BC8704Ce76DDcd00cf3a83Acd24de4101eE2D) | 0x408BC8704Ce76DDcd00cf3a83Acd24de4101eE2D |  |

| **Global Instances** | **Address** |  |
| --- | --- | --- |
| [Global Feed](https://explorer.testnet.lens.xyz/address/0x31232Cb7dE0dce17949ffA58E9E38EEeB367C871) | 0x31232Cb7dE0dce17949ffA58E9E38EEeB367C871 |  |
| [Global Graph](https://explorer.testnet.lens.xyz/address/0x4d97287FF1A0e030cA4604EcDa9be355dd8A8BaC) | 0x4d97287FF1A0e030cA4604EcDa9be355dd8A8BaC |  |
| [Lens Namespace](https://explorer.testnet.lens.xyz/address/0xFBEdC5C278cc01A843D161d5469202Fe4EDC99E4) | 0xFBEdC5C278cc01A843D161d5469202Fe4EDC99E4 |  |
| [Test App](https://explorer.testnet.lens.xyz/address/0xC75A89145d765c396fd75CbD16380Eb184Bd2ca7) | 0xC75A89145d765c396fd75CbD16380Eb184Bd2ca7 |  |

| **Auxiliary** | **Address** |  |
| --- | --- | --- |
| [ActionHub](https://explorer.testnet.lens.xyz/address/0x4A92a97Ff3a3604410945ae8CA25df4fBB2fDC11) | 0x4A92a97Ff3a3604410945ae8CA25df4fBB2fDC11 |  |

| **Actions** | **Address** |  |
| --- | --- | --- |
| [TippingAccountAction](https://explorer.testnet.lens.xyz/address/0xda614A06972C70a8d50D494FB678d48cf536f769) | 0xda614A06972C70a8d50D494FB678d48cf536f769 |  |
| [TippingPostAction](https://explorer.testnet.lens.xyz/address/0x34EF0F5e41cB6c7ad9438079c179d70C7567ae00) | 0x34EF0F5e41cB6c7ad9438079c179d70C7567ae00 |  |
| [SimpleCollectAction](https://explorer.testnet.lens.xyz/address/0x17d5B3917Eab14Ab4923DEc597B39EF64863C830) | 0x17d5B3917Eab14Ab4923DEc597B39EF64863C830 |  |

| **Graph Rules** | Address |  |
| --- | --- | --- |
| [GroupGatedGraphRule](https://explorer.testnet.lens.xyz/address/0x2Cb90d67d4396385060F4f18B036176005B21d56) | 0x2Cb90d67d4396385060F4f18B036176005B21d56 |  |
| [TokenGatedGraphRule](https://explorer.testnet.lens.xyz/address/0x2662F99dC985d3dC710D3c13142e2D156874878d) | 0x2662F99dC985d3dC710D3c13142e2D156874878d |  |

| **Group Rules** | Address |  |
| --- | --- | --- |
| [BanMemberGroupRule](https://explorer.testnet.lens.xyz/address/0xd12E1aD028d550F85F2a8d9130C46dB77A6A0a41) | 0xd12E1aD028d550F85F2a8d9130C46dB77A6A0a41 |  |
| [MembershipApprovalGroupRule](https://explorer.testnet.lens.xyz/address/0x6d467E7f34e87C0D7185FAf692B43eD5792B86f5) | 0x6d467E7f34e87C0D7185FAf692B43eD5792B86f5 |  |
| [SimplePaymentGroupRule](https://explorer.testnet.lens.xyz/address/0xC99b11687d91EC4f6e65EcFa205795101BbaB5B2) | 0xC99b11687d91EC4f6e65EcFa205795101BbaB5B2 |  |
| [TokenGatedGroupRule](https://explorer.testnet.lens.xyz/address/0x3e3a35d2A67583975569c4a19761268AFB958cEF) | 0x3e3a35d2A67583975569c4a19761268AFB958cEF |  |

| **Feed Rules** | Address |  |
| --- | --- | --- |
| [GroupGatedFeedRule](https://explorer.testnet.lens.xyz/address/0xbDE71d01eC6d6c49b2bcc9067EcA352a17D25A91) | 0xbDE71d01eC6d6c49b2bcc9067EcA352a17D25A91 |  |
| [SimplePaymentFeedRule](https://explorer.testnet.lens.xyz/address/0x55efA60BE4fd711C114B853A5d251b95bdCC4F66) | 0x55efA60BE4fd711C114B853A5d251b95bdCC4F66 |  |
| [TokenGatedFeedRule](https://explorer.testnet.lens.xyz/address/0x54649BfA8Ea33eDD90f93592Fe87627be6C76013) | 0x54649BfA8Ea33eDD90f93592Fe87627be6C76013 |  |

| **Namespace Rules** | Address |  |
| --- | --- | --- |
| [UsernameSimpleCharsetNamespaceRule](https://explorer.testnet.lens.xyz/address/0x1dB51f49DE4D266B2ab7D62656510083e0AACe44) | 0x1dB51f49DE4D266B2ab7D62656510083e0AACe44 |  |
| [UsernameLengthNamespaceRule](https://explorer.testnet.lens.xyz/address/0x0F0Fe596bAfddbd2Eb4037Fc111b9C4aE5192C5C) | 0x0F0Fe596bAfddbd2Eb4037Fc111b9C4aE5192C5C |  |
| [UsernameReservedNamespaceRule](https://explorer.testnet.lens.xyz/address/0x9a8b0e3344f5ca5f6fc9FcEb8fF543FDeF5eb2b9) | 0x9a8b0e3344f5ca5f6fc9FcEb8fF543FDeF5eb2b9 |  |
| [TokenGatedNamespaceRule](https://explorer.testnet.lens.xyz/address/0x87A69174530aA735768096c5F24a0F559553Dd84) | 0x87A69174530aA735768096c5F24a0F559553Dd84 |  |
| [UsernamePricePerLengthNamespaceRule](https://explorer.testnet.lens.xyz/address/0x4aBdf719Bc6659e91233c62D4d08D6F4229989e8) | 0x4aBdf719Bc6659e91233c62D4d08D6F4229989e8 |  |

| **Follow Rules** | Address |  |
| --- | --- | --- |
| [SimplePaymentFollowRule](https://explorer.testnet.lens.xyz/address/0x7EA84D750E8C2b7D0EB5e8114f54111d78Eeb992) | 0x7EA84D750E8C2b7D0EB5e8114f54111d78Eeb992 |  |
| [TokenGatedFollowRule](https://explorer.testnet.lens.xyz/address/0x51BB76bae8eb8f1B69B8F4c3e310d49423a9aF33) | 0x51BB76bae8eb8f1B69B8F4c3e310d49423a9aF33 |  |

| **Post Rules** | Address |  |
| --- | --- | --- |
| [FollowersOnlyPostRule](https://explorer.testnet.lens.xyz/address/0x8956af058dF5Cb3609Fc10B2ea293764f55F5B0c) | 0x8956af058dF5Cb3609Fc10B2ea293764f55F5B0c |  |

| **Global Rules** | Address |  |
| --- | --- | --- |
| [AccountBlockingRule](https://explorer.testnet.lens.xyz/address/0xf3de16e99679243E36BB449CADEA247Cf61450e1) | 0xf3de16e99679243E36BB449CADEA247Cf61450e1 |  |

## Lens Contracts

You can find the source code for the Lens smart contracts on [GitHub](https://github.com/lens-protocol/lens-v3/tree/latest-testnet).

[Previous\\
\\
**Post an Image**](https://lens.xyz/docs/protocol/tutorials/post-an-image) [Next\\
\\
**Changelog**](https://lens.xyz/docs/protocol/resources/changelog)

## Create a Lens App
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Create an App

This guide will walk you through the process of creating a Lens App.

To create an App, follow these steps.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) create an App.

1

## Create App Metadata

First, construct an App Metadata object with the necessary content.

- TS/JS
- JSON Schema

Use the @lens-protocol/metadata package to construct a valid AppMetadata object:

```
import { MetadataAttributeType, app } from "@lens-protocol/metadata";
const metadata = app({  name: "XYZ",  tagline: "The next big thing",  description: "An app to rule them all",  logo: "lens://4f91cab87ab5e4f5066f878b72…",  developer: "John Doe <john.doe@email.com>",  url: "https://example.com",  termsOfService: "https://example.com/terms",  privacyPolicy: "https://example.com/privacy",  platforms: ["web", "ios", "android"],});
```

2

## Upload App Metadata

Next, upload the App Metadata object to a public URI.

```
import { storageClient } from "./storage-client";
const { uri } = await storageClient.uploadAsJson(metadata);
console.log(uri); // e.g., lens://4f91ca…
```

This example uses [Grove storage](https://lens.xyz/docs/storage) to host the Metadata object.
See the [Lens Metadata\\
Standards](https://lens.xyz/docs/protocol/best-practices/metadata-standards#host-metadata-objects) guide
for more information on hosting Metadata objects.

3

## Deploy App Contract

Next, deploy the Lens App smart contract.

- TypeScript
- GraphQL

Use the createApp action to deploy the Lens App smart contract.

```
import { uri } from "@lens-protocol/client";import { createApp } from "@lens-protocol/client/actions";
// …
const result = await createApp(sessionClient, {  metadataUri: uri("lens://4f91…"), // the URI from the previous step  defaultFeed: {    globalFeed: true,  },  graph: {    globalGraph: true,  },  namespace: {    globalNamespace: true,  },});
```

4

## Handle Result

- TypeScript
- GraphQL

Finally, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await createApp(sessionClient, {  metadataUri: uri("lens://4f91…"), // the URI from the previous step}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

That's it—you now can start using your Lens App!

[Previous\\
\\
**Apps**](https://lens.xyz/docs/protocol/apps) [Next\\
\\
**Fetch Apps**](https://lens.xyz/docs/protocol/apps/fetch)

## Lens Protocol Changelog
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Changelog

All notable changes to this project will be documented in this page.

This page collects any notable changes to the Lens Protocol v3, API, and SDK.

25 April 2025

List of changes that are currently in progress and will be released soon.

24 April 2025

## Faster App Verification

The App Verification (also known as Operation Verification) process, previously relying on a server-to-server call to an app-provided Verification Endpoint, has been replaced with a new approach based on the exchange of App Signer signing keys.

This change eliminates the server-to-server call latency that was inherent in the previous verification process.

### Changed

The app-provided Authorization Endpoint should return the signing key of an App Signer:

```
HTTP/1.1 200 OKContent-Type: application/json
{  "allowed": true,  "sponsored": true,- "appVerificationEndpoint": "https://example.com/verify"+ "signingKey": "0x1234…"}
```

The Verification Endpoint is no longer required and can be removed from the app's code.

See the updated [Authorization Workflows](https://lens.xyz/docs/protocol/apps/authorization-workflows) guide for more details.

4 April 2025

## Bugfixes and Improvements

Refinements to the GraphQL API and SDK.

### Changed

Since the UsernameReservedNamespaceRule is applied by default to any Namespace created through the Lens factories, it is no longer necessary to specify it in the rules field when creating a Namespace.

```
mutation {  createUsernameNamespace(    request: {      symbol: "FOO"      namespace: "foo"      metadataURI: "lens://4f91ca…"      rules: {        required: [-         {-           usernameReservedRule: { reserved: ["asdfgh"] }-         }        ]      }    }  ) {    ... on CreateNamespaceResponse {      hash    }    ... on SelfFundedTransactionRequest {      ...SelfFundedTransactionRequest    }    ... on TransactionWillFail {      reason    }  }}
```

3 April 2025

## Bugfixes and Improvements

### Changed

A minor renaming of GraphQL input types has been implemented. This change will only impact you if you use these input types as operation parameters, as demonstrated below.

If you are using the Lens SDK, simply update to the latest @canary version to accommodate this change.

```
- query ExploreQuery($request: MlexplorePostsRequest!) {+ query ExploreQuery($request: PostsExploreRequest!) {    value: mlPostsExplore(request: $request) {      __typename      items {        ...Post      }      pageInfo {        ...PaginatedResultInfo      }    }  }
```

```
- query PostsForYou($request: MlpostsForYouRequest!) {+ query PostsForYou($request: PostsForYouRequest!) {    value: mlPostsForYou(request: $request) {      __typename      items {        ...PostForYou      }      pageInfo {        ...PaginatedResultInfo      }    }  }
```

1 April 2025

## Prepare for Mainnet

### Stable Lens Metadata Standard

The [Lens Metadata Standard package](https://github.com/lens-protocol/metadata) has reached a **stable 2.0 release** — no functional changes, just a transition to a stable version.

Update to:

```
npm install @lens-protocol/metadata@latest
```

to align with the stable 2.x version.

### Updated Lens Chain SDK

The dependency on the Lens Chain SDK has been updated to the [latest stable version](https://lens.xyz/docs/chain/resources/changelog#2025-04-01-prepare-for-mainnet).

Make sure to update to the latest Lens SDK canary and Lens Chain SDK stable version.

```
npm install @lens-chain/sdk@latest @lens-protocol/client@canary
```

27 March 2025

## Bugfixes and Improvements

This release includes several bug fixes and improvements.

### Changed

#### Expose Feed Under Group.feed

The Group.feed field has been upgraded to a fully-fledged Feed object. If you are using the Lens SDK, simply update to the latest version to access the new feed object.

If you are not using the SDK, update your GraphQL fragments as demonstrated below.

```
fragment Group on Group {  __typename  address- feed+ feed {+   ...Feed+ }  timestamp  owner  banningEnabled  membershipApprovalEnabled  metadata {    ...GroupMetadata  }  rules {    ...GroupRules  }  operations {    ...LoggedInGroupOperations  }}
```

#### SessionClient\#getAuthenticatedUser No Longer Returns a Thenable

In the usage below is not a breaking change per-se since any await expression implicitly wraps the value in a Promise. However, your linter/IDE may flag this as an error.

```
- const result = await sessionClient.getAuthenticatedUser();+ const result = sessionClient.getAuthenticatedUser();
```

#### BanMemberGroupRule Applied Automatically

The BanMemberGroupRule does not require any configuration because it is applied automatically when a Group is created.

```
import { evmAddress, uri } from "@lens-protocol/client";import { createGroup } from "@lens-protocol/client/actions";
const result = await createGroup(sessionClient, {  metadataUri: uri("lens://4f91c…"),-  rules: {-   required: [-    {-      banAccountRule: {-        enable: true,-      },-    },-   ],  },});
```

25 March 2025

## New Full Protocol Release

With this release, we redeployed a completely new protocol and reset all testnet state.

Update the latest @lens-protocol/client@canary and use the following diffs to update your GQL fragments.

### Changed

To create a Post with paid-collect, group the relevant properties under the payToCollect property.

```
import { dateTime, evmAddress, uri } from "@lens-protocol/client";
const result = await post(sessionClient, {  contentUri: uri("lens://4f91ca…"),  actions: [    {      simpleCollect: {-       amount: {-         currency: evmAddress("0x1234…"),-         value: "42.42",-       },-       recipients: [-         {-           address: evmAddress("0x5678…"),-           percent: 30, // 30%-         },-         {-           address: evmAddress("0x9abc…"),-           percent: 70, // 70%-         },-       ],-       referralShare: 5, // 5%+       payToCollect: {+         amount: {+           currency: evmAddress("0x1234…"),+           value: "42.42",+         },+         recipients: [+           {+             address: evmAddress("0x5678…"),+             percent: 30, // 30%+           },+           {+             address: evmAddress("0x9abc…"),+             percent: 70, // 70%+           },+         ],+         referralShare: 5, // 5%+       },      },    },  ],});
```

The SimpleCollectActionConfig properties related to paid-collect are now grouped under the payToCollect property.

```
fragment SimpleCollectAction on SimpleCollectAction {  __typename  address- amount {-   ...Erc20Amount- }- recipients {-   ...RecipientPercent- }- referralShare+ payToCollect {+   __typename+   amount {+     ...Erc20Amount+   }+   recipients {+     ...RecipientPercent+   }+   referralShare+ }  collectLimit  followerOnGraph {    ...FollowerOn  }  endsAt  isImmutable  collectNftAddress}
```

10 March 2025

## Image Resizing and Original URIs

This release introduces changes that allow resizing of Post, Account, and other metadata image URLs, as well as the option to retrieve the original Lens URIs for media URLs. Additionally, it includes various bug fixes and improvements.

### Changed

UnknownAction got split into UnknownAccountAction and UnknownPostAction.

```
fragment AccountAction on AccountAction {  __typename  ... on TippingAccountAction {    ...TippingAccountAction  }  ... on UnknownAccountAction {-   ...UnknownAction+   ...UnknownAccountAction  }}
+ fragment UnknownAccountAction on UnknownAccountAction {+   __typename+   address+   config {+     ...AnyKeyValue+   }+   metadata {+     ...ActionMetadata+   }+ }fragment PostAction on PostAction {  ... on SimpleCollectAction {    ...SimpleCollectAction  }  ... on UnknownPostAction {-    ...UnknownAction+    ...UnknownPostAction  }}
+ fragment UnknownPostAction on UnknownPostAction {+   __typename+   address+   config {+     ...AnyKeyValue+   }+   metadata {+     ...ActionMetadata+   }+ }- fragment UnknownAction on UnknownAction {-   __typename-   address-   config {-     ...AnyKeyValue-   }-   metadata {-     ...ActionMetadata-   }- }
```

Some EventMetadata fields got renamed for consistency with other metadata objects.

```
fragment EventMetadata on EventMetadata {  …  location {-   ...EventMetadataLensLocation+   ...EventLocation  }  …  schedulingAdjustments {-   ...EventMetadataLensSchedulingAdjustments+   ...EventSchedulingAdjustments  }  …}
- fragment EventMetadataLensLocation on EventMetadataLensLocation {+ fragment EventLocation on EventLocation {  __typename  physical  virtual}
- fragment EventMetadataLensSchedulingAdjustments on EventMetadataLensSchedulingAdjustments {+ fragment EventSchedulingAdjustments on EventSchedulingAdjustments {  __typename  timezoneId  timezoneOffset}
```

5 March 2025

### Changed

Removed redundant title field from Graph, Feed, and Action metadata objects. Use name field instead.

- Update the @lens-protocol/metadata@next to get the correct builder functions.

- Update the @lens-protocol/client@canary or use the following diffs to update your GQL fragments.


```
fragment GraphMetadata on GraphMetadata {  __typename  description  id  name- title}
```

4 March 2025

## Relocate Lens Chain SDK

The Lens Chain SDK has been relocated under: @lens-chain/sdk. Since it's a peer dependency fo the @lens-protocol/client, you need to update the package in your project.

```
npm uninstall @lens-network/sdknpm install @lens-chain/sdk@canary
```

22 February 2025

## Bugfixes and Improvements

### Changed

Fix to structural typing mismatch of AnyKeyValue union.

- TypeScript
- GraphQL

Update to the latest @lens-protocol/client@canary to get the latest types.

```
type ArrayKeyValue = {  __typename: "ArrayKeyValue";  key: string;+ array:- value:    | IntKeyValue    | IntNullableKeyValue    | AddressKeyValue    | StringKeyValue    | BooleanKeyValue    | RawKeyValue    | BigDecimalKeyValue    | DictionaryKeyValue;};
```

14 February 2025

## Bugfixes and Improvements

### Added

- New whoExecutedActionOnPost query (fetchWhoExecutedActionOnPost SDK action).

- New Post.contentUri field surfaces the original Content URI of the Post.


### Changed

#### TimelineItem fix

The TimelineItem.reposts was incorrectly returning array of Post, instead it should return array of Repost.

```
fragment TimelineItem on TimelineItem {  __typename  id  primary {    ...Post  }  comments {    ...Post  }  reposts {-   ...Post+   ...Repost  }}
```

#### Simple Collect Action

Prepare Simple Collect Action GQL to support multi-recipient. Support at contract level coming soon.

- TypeScript
- GraphQL

```
const result = await executePostAction(sessionClient, {  post: postId("42"),  action: {-   simpleCollect: true,+   simpleCollect: {+     selected: true,+   },  },});
```

#### Post Actions

The whoActedOnPost query (fetchWhoActedOnPost SDK action) is now whoExecutedActionOnAccount (fetchWhoExecutedActionOnAccount SDK action).

10 February 2025

## Actions, Rules, and Sponsorships

### Added

- Follow Rules

- Feed Rules

- Graph Rules

- Username Namespace Rules

- Group Rules

- Post Rules

- Post Actions

- Account Actions

- Sponsorship support: apps can now sponsor their own users


### Changed

- Logged-in operations objects:


- Post.operations.canEdit, Post.operations.canDelete, Post.operations.canComment, Post.operations.canQuote, Post.operations.canRepost now returns a new PostOperationValidationOutcome union with all the details regarding rules validation.

- Account.operations.canFollow and Account.operations.canUnfollow now returns a new AccountFollowOperationValidationOutcome union with all the details regarding rules validation.


- Paginated query postActions got renamed into postActionContracts and the return type is now consolidated, including ActionMetatada for unknown Post Actions.


18 December 2024

Routine release with several bug fixes and improvements.

### Changed

NestedPost and PostReference nodes got removed.

```
fragment Post on Post {  id  author {    ...Account  }  metadata {    ...PostMetadata  }  root {-   ...NestedPost+   ...ReferencedPost  }  quoteOf {-   ...NestedPost+   ...ReferencedPost  }  commentOn {-   ...NestedPost+   ...ReferencedPost  }  stats {    ...PostStats  }}
```

where:

```
fragment ReferencedPost on Post {  id  author {    ...Account  }  metadata {    ...PostMetadata  }
  # root, quoteOf, commentOn omitted to avoid circular references}
```

25 November 2024

## Lens API Testnet

Lens API Testnet is now available for developers to start building and testing their applications.

### Changed

#### Explicit Authentication Roles

The challenge mutation now requires explicit authentication roles to be passed in the request.

```
mutation {  challenge(    request: {-      app: "<app-address>"-      account: "<account-address>"-      signedBy: "<owner-address>"+      accountOwner: {+        app: "<app-address>"+        account: "<account-address>"+        owner: "<owner-address>"+      }    }  ) {    __typename    id    text  }}
```

12 November 2024

## Developer Preview Announcement

## Username System Overview
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

simonesfoodie@Lenssimonescakes@Family

# Username

The Username system on Lens offers a flexible and customizable approach to user identities. While there is a global namespace like "lens",
applications can deploy their own namespaces, such as app/username, allowing them to create unique username ecosystems and even generate revenue.
This hierarchical structure enables apps to align usernames with their brand and community, fostering a more personalized user experience.

Usernames are deployed as individual contracts, which are tokenized for tradable access.
Developers can set minting rules such as charging a fee or requiring ownership of a specific NFT—using the modular rule system. Additional features include defining
minimum and maximum username lengths, setting secondary royalties compliant with EIP-2981, and managing admin access. This comprehensive system provides both flexibility
and control over how usernames are created and managed within the network.

[Previous\\
\\
**Feed**](https://lens.xyz/docs/protocol/concepts/feed) [Next\\
\\
**Graph**](https://lens.xyz/docs/protocol/concepts/graph)

## Lens API Migration
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# API Migration

This guide will walk you through the necessary steps to upgrade to the latest versions of the API.

This guide assumes familiarity with Lens Protocol v2 and the Lens API v2.

## Changed API Calls

This guide below will list old Lens v2 GraphQL queries and mutations mapped to the new Lens v3 ones.
As GraphQL is a type system we will not describe if the request object has changed as you can easily
see this on the GraphQL playground. Note we have not integrated actions and rules yet in the API and indexer so they are missing from here for now.

### Queries

#### Restructured

Only listing changes from v2 to v3 and not any new queries.

- challenge \> now a mutation

- verify \> [use RSA keys to verify](https://lens.xyz/docs/protocol/migration/docs/features/authentication#advanced-topics-authentication-tokens)

- approvedAuthentications \> authenticatedSessions

- currentSession \> currentSession

- ownedHandles \> usernames

- handleToAddress \> account

- feed \> timeline

- feedHighlights \> timelineHighlights

- mutualFollowers \> followersYouKnow

- followStatusBulk \> followStatus

- profiles \> accountsBulk

- profile \> account

- profileInterestsOptions \> it will be moved to metadata

- whoHaveBlocked \> accountsBlocked

- lastLoggedInProfile \> lastLoggedInAccount

- profileManagers \> accountManagers

- profilesManaged \> accountsAvailable

- profileRecommendations \> mlAccountRecommendations

- searchProfiles \> accounts

- publications \> posts and postReferences

- publication \> post

- publicationsTags \> postTags

- publicationBookmarks \> postBookmarks

- whoReactedPublication \> postReactions

- didReactOnPublication \> postReactionsStatus

- explorePublications \> mlPostsExplore

- validatePublicationMetadata \> debugMetadata

- forYou \> mlPostsForYou

- searchPublications \> posts

- userRateLimit \> me (under SponsorshipAllowance)

- lensTransactionStatus \> transactionStatus

- whoActedOnPublication \> whoExecutedActionOnPost

- supportedOpenActionModules \> postActionContracts

- supportedFollowModules \> Not complete yet

- moduleMetadata \> it's inlined in the relevant GQL notes (e.g. UnknownAction.metadata)


#### Deprecated

- approvedModuleAllowanceAmount

- canClaim

- claimableProfiles

- claimableStatus

- claimableTokens

- claimTokens

- defaultProfile

- exploreProfiles

- followRevenues

- generateLensAPIRelayAddress

- generateModuleCurrencyApprovalData

- invitedProfiles

- latestPaidActions

- lensAPIOwnedEOAs

- lensProtocolVersion

- momokaSubmitters

- momokaSummary

- momokaTransaction

- momokaTransactions

- mutualNftCollections

- mutualPoaps

- nftCollectionOwners

- nftCollections

- nftGalleries

- nfts

- poapEvent

- poapHolders

- poaps

- popularNftCollections

- profileActionHistory

- profileAlreadyInvited

- relayQueues

- revenueFromPublication

- revenueFromPublications

- setDefaultProfile

- txIdToTxHash

- userSigNonces


### Mutations

#### Restructured

Only listing changes from v2 to v3 and not any new mutations.

- walletAuthenticationToProfileAuthentication \> switchAccount

- linkHandleToProfile \> assignUsernameToAccount

- unlinkHandleFromProfile \> unassignUsernameFromAccount

- createLinkHandleToProfileTypedData \> assignUsernameToAccount

- createUnlinkHandleFromProfileTypedData \> unassignUsernameFromAccount

- createFollowTypedData \> follow

- createUnfollowTypedData \> unfollow

- setFollowModule \> setAccountFollowRule

- createSetFollowModuleTypedData \> setAccountFollowRule

- postOnMomoka \> post

- commentOnMomoka \> post

- quoteOnMomoka \> post

- mirrorOnMomoka \> post

- createMomokaQuoteTypedData \> post

- createMomokaPostTypedData \> post

- createMomokaCommentTypedData \> post

- createMomokaMirrorTypedData \> post

- addProfileInterests \> setAccountMetadata

- removeProfileInterests \> setAccountMetadata

- dismissRecommendedProfiles \> mlDismissRecommendedAccounts

- reportProfile \> reportAccount

- peerToPeerRecommend \> recommendAccount

- peerToPeerUnrecommend \> undoRecommendedAccount

- hideManagedProfile \> hideManagedAccount

- unhideManagedProfile \> unhideManagedAccount

- setProfileMetadata \> setAccountMetadata

- createOnchainSetProfileMetadataTypedData \> setAccountMetadata

- createChangeProfileManagersTypedData \> addAccountManager, removeAccountManager and updateAccountManager

- createBlockProfilesTypedData \> block

- createUnblockProfilesTypedData \> unblock

- hidePublication \> deletePost

- hideComment \> hideReply

- unhideComment \> unhideReply

- addPublicationNotInterested \> mlAddPostNotInterested

- undoPublicationNotInterested \> mlUndoPostNotInterested

- addPublicationBookmark \> bookmarkPost

- removePublicationBookmark \> undoBookmarkPost

- removeReaction \> undoReaction

- reportPublication \> reportPost

- postOnchain \> post

- commentOnchain \> post

- quoteOnchain \> post

- mirrorOnchain \> post

- refreshPublicationMetadata \> editPost

- createOnchainPostTypedData \> post

- createOnchainCommentTypedData \> post

- createOnchainQuoteTypedData \> post

- createOnchainMirrorTypedData \> post

- actOnOpenAction \> Not complete yet

- createActOnOpenActionTypedData \> Not complete yet


#### Deprecated

- broadcastOnMomoka \> use post for everything

- broadcastOnchain

- legacyCollect

- createLegacyCollectTypedData

- createNftGallery

- updateNftGalleryInfo

- updateNftGalleryOrder

- updateNftGalleryItems

- deleteNftGallery

- nftOwnershipChallenge

- claimProfileWithHandle

- invite

- idKitPhoneVerifyWebhook


## Processes

- Typed data does not exist anymore its handled all in the mutation response union

- Momoka does not exist anymore

- Tx Id does not exist anymore


### Seamless Authentication Rollover

In order to provide a seamless transition for users, we have implemented a new authentication mechanism that allows you to refresh tokens from Refresh Token issued by the Lens API v2.

You can call the legacyRolloverRefresh mutation to acquire new authentication tokens.

```
mutation {  legacyRolloverRefresh(request: { refreshToken: "<legacy-refresh-token>" }) {    ... on AuthenticationTokens {      accessToken      refreshToken      idToken    }
    ... on ForbiddenError {      reason    }  }}
```

The provided Refresh Token must still be valid. Since they last for 7 days
from the time they are issued, this rollover mechanism is a short-term
solution to allow for a seamless transition. If you think that most of your
app's users will have their Refresh Token expired by the time they try to
log-in into your Lens v3 app, you probably can omit this integration and just
force users to re-authenticate.

## New Features

Explore the Lens v3 documentation for all the new features.

[Previous\\
\\
**SDK**](https://lens.xyz/docs/protocol/migration/sdk) [Next\\
\\
**Database**](https://lens.xyz/docs/protocol/migration/database)

## Account Notifications Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Notifications

This guide will help you retrieve Account related notifications.

When an Account interacts with you or your content, the activity is recorded and notification detailing the interaction is stored in the Lens API.

## Notification types

There are various types of notifications, each with a slightly different structure, requiring individual handling. The available notification types include:

- **CommentNotification** \- when someone comments on your post

- **FollowNotification** \- when someone follows you

- **MentionNotification** \- when someone mentions you in a post

- **RepostNotification** \- when someone reposts your post

- **QuoteNotification** \- when someone quotes your post

- **ReactionNotification** \- when someone adds reaction to your post


At any given time new notification types may be added to the Lens API.
Make sure you handle gracefully unknown notification types to avoid breaking your app.

## Notifications Query

You MUST be authenticated as Account Owner or Account Manager to make this
request.

- TypeScript
- GraphQL
- React

Use the paginated fetchNotifications action to retrieve notifications for an Account.

```
import { evmAddress } from "@lens-protocol/client";import { fetchNotifications } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await fetchNotifications(client, {});
if (result.isErr()) {  return console.error(result.error);}
// items: Array<Notification>const { items, pageInfo } = result.value;
```

Continue with the [Pagination](https://lens.xyz/docs/protocol/best-practices/pagination) guide for more information on how to handle paginated results.

[Previous\\
\\
**Account Funds**](https://lens.xyz/docs/protocol/accounts/funds) [Next\\
\\
**Feeds**](https://lens.xyz/docs/protocol/feeds/post)

## Fetch Lens Accounts
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Fetch Accounts

This guide will help you with fetching Account data from the Lens API.

Lens Account data is comprised of:

- Account Identity

- Account Metadata

- ML Score

- Operational flags


To illustrate how to fetch accounts, we will use the following fragment, which includes some of the most common fields of an Account:

```
fragment Account on Account {  address  username {    value  }  metadata {    name    picture  }}
```

In the end of this guide, we will expand on some of the fields that are not fully covered in the example above.

## Get an Account

- TypeScript
- GraphQL
- React

Use the fetchAccount action to fetch an Account by its address, username, txHash or legacy Lens v2 ID.

```
import { evmAddress } from "@lens-protocol/client";import { fetchAccount } from "@lens-protocol/client/actions";import { client } from "./client";
const result = await fetchAccount(client, {  address: evmAddress("0x1234…"),});
if (result.isErr()) {  return console.error(result.error);}
const account = result.value;
```

## Bulk Accounts List

- TypeScript
- GraphQL
- React

Use the fetchAccountsBulk action to fetch a finite number of accounts by their addresses, usernames, or legacy Lens v2 IDs.

```
import { evmAddress } from "@lens-protocol/client";import { fetchAccountsBulk } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await fetchAccountsBulk(client, {  addresses: [evmAddress("0x1234…"), evmAddress("0x5678…")],});
if (result.isErr()) {  return console.error(result.error);}
// Array<Account>const accounts = result.value;
```

## Search Accounts

- TypeScript
- GraphQL
- React

Use the paginated fetchAccounts action to search for accounts by their usernames.

```
import { fetchAccounts } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await fetchAccounts(client, {  filter: {    searchBy: {      localNameQuery: "wagmi",    },  },});
if (result.isErr()) {  return console.error(result.error);}
// items: Array<Account>const { items, pageInfo } = result.value;
```

Continue with the [Pagination](https://lens.xyz/docs/protocol/best-practices/pagination) guide for more information on how to handle paginated results.

## Recommended Accounts

Accounts recommendations are generated by leveraging a user's social graph and engagement data. Machine learning is employed to rank potential accounts to follow, based on the likelihood and quality of interaction.

### Fetch Recommendations

- TypeScript
- GraphQL
- React

Use the paginated fetchAccountRecommendations action to retrieve a list of recommended Accounts based on Lens Machine Learning (ML) algorithms.

```
import { evmAddress } from "@lens-protocol/client";import { fetchAccountRecommendations } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await fetchAccountRecommendations(client, {  account: evmAddress("0x1234…"),  shuffle: true, // optional, shuffle the results});
if (result.isErr()) {  return console.error(result.error);}
// items: Array<Account>const { items, pageInfo } = result.value;
```

Continue with the [Pagination](https://lens.xyz/docs/protocol/best-practices/pagination) guide for more information on how to handle paginated results.

### Dismiss Recommendations

When you dismiss recommended Accounts, they are removed from your suggestions and the recommendation algorithm adjusts accordingly.

You MUST be authenticated as the Account Owner or Account Manager to dismiss
account recommendations for a given Lens Account.

- TypeScript
- GraphQL
- React

Use the dismissRecommendedAccount action to remove Accounts from the list of recommendations.

```
import { evmAddress } from "@lens-protocol/client";import { dismissRecommendedAccount } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await dismissRecommendedAccount(client, {  accounts: [evmAddress("0x1234…"), evmAddress("0x5678…")],});
if (result.isErr()) {  return console.error(result.error);}
```

## Account Fields

In this section we will expand on some of the Account fields that are not covered in the examples above.

### Account Identity

An Account can have one or more usernames across different namespaces, but only one username per namespace.

By default, the username field returns the username in the lens/ namespace, if available. It also accepts an optional argument to specify a different namespace.

```
fragment Account on Account {  # ...
  username {    ...Username  }
  socialX: username(request: { namespace: "0x1234…" }) {    ...Username  }}
```

### Account Metadata

Although briefly mentioned in the examples, the metadata field is a rich object that can include a variety of information about the account.

It contains the Account Metadata object that was linked to the Account at the time of creation or update. This object can include the following fields:

See the [Create an Account](https://lens.xyz/docs/protocol/accounts/create) guide for more information on how this
object is created.

```
type AccountMetadata {  # A bag of attributes.  attributes: [MetadataAttribute!]!
  # The profile bio as markdown.  bio: String
  # The profile cover picture.  coverPicture: URI
  # A unique identifier.  id: String!
  # The profile display name.  name: String
  # The profile picture.  picture: URI}
```

### Account Score

The Lens team has implemented a series of measures to uphold the integrity of the Lens ecosystem. The Account Score is a probability-based measure that evaluates an account's signal strength, helping to reduce the impact of spammy behavior on the user experience. This score is calculated using a set of ML algorithms that consider factors like follower graphs, content, and other variables. Higher scores suggest a positive and active presence within the ecosystem.

```
fragment Account on Account {  # ...
  score}
```

### Logged-In Operations

The Lens schema allows logged-in users to fetch details about available actions and actions already taken, via the operations field.

```
type Account = {  operations: LoggedInAccountOperations | null;};
type LoggedInAccountOperations = {  isFollowedByMe: boolean;  isFollowingMe: boolean;  canFollow: OperationValidationOutcome | null;  canUnfollow: OperationValidationOutcome | null;  isMutedByMe: boolean;  isBlockedByMe: boolean;  hasBlockedMe: boolean;  canBlock: OperationValidationOutcome | null;  canUnblock: OperationValidationOutcome | null;  hasReported: boolean;};
```

The LoggedInAccountOperations type specifies the actions the user can perform (e.g., _canFollow_, _canBlock_) and the actions already taken (e.g., _isFollowedByMe_, _isBlockedByMe_).

Where:

- isFollowedByMe: Indicates whether the logged-in account follows the account.

- isFollowingMe: Indicates whether the account follows the logged-in account.

- canFollow: Indicates whether the logged-in account can follow the account.

- canUnfollow: Indicates whether the logged-in account can unfollow the account.

- isMutedByMe: Indicates whether the account is muted by the logged-in account.

- isBlockedByMe: Indicates whether the account is blocked by the logged-in account.

- hasBlockedMe: Indicates whether the account has blocked the logged-in account.

- canBlock: Indicates whether the logged-in account can block the account.

- canUnblock: Indicates whether the logged-in account can unblock the account.

- hasReported: Indicates whether the logged-in account has reported the account.


Fields returning an OperationValidationOutcome give information on the feasibility of the operation. More details in the [Querying Data](https://lens.xyz/docs/protocol/best-practices/querying-data#operation-validation) guide.

The isFollowedByMe, isFollowingMe, canFollow, and canUnfollow fields accept an optional argument specifying the Graph address to check the follow status.

- GraphQL
- TypeScript

Alias the corresponding fields as needed:

```
fragment LoggedInAccountOperations on LoggedInAccountOperations {  isFollowedByMeOnMyGraph: isFollowedByMe(request: { graph: "0x1234…" })
  isFollowingMeOnMyGraph: isFollowingMe(request: { graph: "0x1234…" })
  canFollowOnMyGraph: canFollow(request: { graph: "0x1234…" }) {    ...OperationValidationOutcome  }
  canUnfollowOnMyGraph: canUnfollow(request: { graph: "0x1234…" }) {    ...OperationValidationOutcome  }}
```

If an argument is not provided, the query follows a fallback approach:

- It first checks for a Graph address specified within the query scope.

- If no Graph address is found, it defaults to using the global Lens Graph.


[Previous\\
\\
**Create an Account**](https://lens.xyz/docs/protocol/accounts/create) [Next\\
\\
**Update Account Metadata**](https://lens.xyz/docs/protocol/accounts/metadata)

## Lens Mentions Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Mentions

This guide will show you how mentions work on Lens.

Mentions are tracked by the Lens API when included in the content field of the [Post](https://lens.xyz/docs/protocol/feeds/post) metadata.

```
import { textOnly } from "@lens-protocol/metadata";
const metadata = textOnly({  content: `Hey @lens/stani, how are you?`,});
```

Lens supports two types of mentions: Account and Group mentions.

## Account Mentions

In Lens, an Account can have multiple usernames, but only one username per [Username Namespace](https://lens.xyz/docs/protocol/usernames/custom-namespaces).

### Global Lens Namespace

A special case is the global Lens Username namespace (i.e., lens/). In this case, account mentions take the familiar form:

```
@lens/<local_name>
```

where <local\_name> is the Lens Account's name under the global Lens Username namespace.

For example:

```
Hey @lens/stani, how are you?
```

### Custom Namespaces

The general format for a mention is:

```
@<namespace_address>/<account_address>
```

where:

- <namespace\_address>: The address of the Username namespace contract associated with the account.

- <account\_address>: The address of the Lens Account being mentioned.


For example:

```
Hey @0x123abc456…/0x789def123…, how are you?
```

- 0x123abc456… is the Username namespace contract address.

- 0x789def123… is the mentioned Lens Account address.


## Group Mentions

Group mentions are similar to Account mentions, but with a different format:

```
#<group_address>
```

where <group\_address> is the address of the Group being mentioned.

For example:

```
To all #0x123abc456… members, please check the latest update.
```

## Rendering Mentions

Use the post.mentions field to replace raw mentions in the Post content with a more user-friendly format.

```
const content = "Hey @0x123abc456…/0x789def123…, how are you?";
const processed = post.mentions.reduce(  (updated, mention) =>    updated.replace(mention.replace.from, mention.replace.to),  content);
// Hey @lens/wagmi, how are you?
```

Below a more detailed example with React.

1

#### Mention Components

Define components for group and account mentions.

```
import React from "react";
export function AccountMention({ children, address }: MentionProps) {  return <a href={`/account/${address}`}>{children}</a>;}
export function GroupMention({ children, address }: MentionProps) {  return <a href={`/group/${address}`}>{children}</a>;}
type MentionProps = {  children: React.ReactNode;  account: string;};
```

2

#### Render Post Content

Replace mentions in the Post content with the corresponding mention component.

This example use [markdown-to-jsx](https://markdown-to-jsx.quantizor.dev/) to render the Post content, but you can use any other library or custom renderer.

```
import React from "react";import Markdown from "markdown-to-jsx";
import { AccountMention } from "./AccountMention";import { GroupMention } from "./GroupMention";import { PostContentProps } from "./PostContentProps";
export function PostContent({ content, mentions }: PostContentProps) {  // Replace mentions in content with custom tags  const processed = mentions.reduce((updated, mention) => {    switch (mention.__typename) {      case "AccountMention":        return updated.replace(          mention.replace.from,          `<AccountMention address="${mention.account}">${mention.replace.to}</AccountMention>`        );      case "GroupMention":        return updated.replace(          mention.replace.from,          `<GroupMention address="${mention.group}">${mention.replace.to}</GroupMention>`        );      default:        return updated;    }  }, content);
  // Render the processed content with Markdown  return (    <Markdown      options={{        overrides: {          AccountMention: {            component: AccountMention,          },          GroupMention: {            component: GroupMention,          },        },      }}    >      {processed}    </Markdown>  );}
```

## Adding Mentions

It's app responsibility to aid users in selecting the correct Account and format mentions correctly in the Post's metadata content.

### Account Mentions

When the user types @ followed by a character, the app should open a lookup interface to help the user select the desired Account.

```
Hey @stan
```

1

#### Account Lookup

- GraphQL
- React
- TypeScript

Use the accounts query to search for Accounts that have a Username matching the search term under the specified namespace.

```
query {  accounts(    request: {      filter: { searchBy: { localNameQuery: "stan" } }      orderBy: BEST_MATCH    }  ) {    items {      address      username {        value        namespace {          address        }      }      metadata {        name        picture      }    }    pageInfo {      prev      next    }  }}
```

Make sure to use the BEST\_MATCH order for the orderBy field to ensure the most relevant results are returned.

In case of multiple namespaces, you can alias the username field to get an
account's username under a specific namespace. It's your app's responsibility
to determine which username to display to the user.

2

#### Display Account Selection

Let's say the previous step returned the following accounts:

```
lens/stanilens/stanleylens/stanford
```

On user's selection, use the provided data to render a user-friendly mention. For example you can use the username.value like so:

```
Hey @<selected.username.value>
```

3

#### Populate Mention in Content

Finally, when submitting the post, include the mention in the Post's metadata content field according to the specification above.

For the global Lens Username namespace, the mention format remains unchanged:

```
import { textOnly } from "@lens-protocol/metadata";
const metadata = textOnly({  content: `Hey @${selected.username.value}, how are you?`,});
```

For custom Username namespaces, include the namespace and account addresses as specified:

```
import { textOnly } from "@lens-protocol/metadata";
const metadata = textOnly({  content: `Hey @${selected.username1.namespace.address}/${selected.address}, how are you?`,});
```

That's it—the Lens indexer will track the mention and notify the mentioned Account.

### Group Mentions

When the user types # followed by a character, the app should open a lookup interface to help the user select the desired Group.

```
To all #build
```

1

#### Group Lookup

- GraphQL
- React
- TypeScript

Use the groups query to search for Groups that have a name matching the search term.

```
query {  groups(request: { filter: { searchQuery: "build" } }) {    items {      address      metadata {        description        icon        name      }    }    pageInfo {      prev      next    }  }}
```

2

#### Display Group Selection

Let's say the previous step returned the following groups:

```
{  "data": {    "groups": {      "items": [        {          "address": "0x1234…",          "metadata": {            "description": "A group for builders",            "icon": "https://example.com/icon.png",            "name": "Builders"          }        },        {          "address": "0x5678…",          "metadata": {            "description": "A group for building",            "icon": "https://example.com/icon.png",            "name": "Building"          }        }      ],      "pageInfo": {        "prev": null,        "next": null      }    }  }}
```

On user's selection, use the provided data to render a user-friendly mention.

```
To all #<selected.metadata.name>
```

3

#### Populate Mention in Content

Finally, when submitting the post, include the mention in the Post's metadata content field according to the specification above.

```
import { textOnly } from "@lens-protocol/metadata";
const metadata = textOnly({  content: `To all #${selected.address} members, please check the latest update.`,});
```

That's it—the Lens indexer will track the mention and populate the post.mentions field with the necessary data.

[Previous\\
\\
**Team Management**](https://lens.xyz/docs/protocol/best-practices/team-management) [Next\\
\\
**Content Licensing**](https://lens.xyz/docs/protocol/best-practices/content-licensing)

## Lens API Authentication
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Authentication

This guide will help you understand how to handle authentication in Lens.

The Lens API uses authentication roles to define different levels of access and interaction:

- **Account Owner**: An end-user who owns a Lens Account.

- **Account Manager**: An end-user managing a Lens Account, either their own or one they have been delegated. See the [Account Managers](https://lens.xyz/docs/protocol/manager) guide for more information.

- **Onboarding User**: A end-user without a Lens Account, limited to features related to onboarding, such as creating an account.

- **Builder**: A developer role used to authenticate and access configuration and management features.


## Log In to Lens

End-user roles such as _Account Owner_, _Account Manager_, or _Onboarding User_ require the EVM address of the App they want to connect to in order to log in to Lens. In contrast, the _Builder_ role does not require an App address for authentication.

For quick experimentation with Lens, a test App has been deployed on each network:

- **Lens Mainnet**: 0x8A5Cc31180c37078e1EbA2A23c861Acf351a97cE

- **Lens Testnet**: 0xC75A89145d765c396fd75CbD16380Eb184Bd2ca7


You can learn how to create your own App in the [Apps guide](https://lens.xyz/docs/protocol/apps) .

- TypeScript
- GraphQL
- React

We'll use viem's [Local Account](https://viem.sh/docs/clients/wallet#local-accounts-private-key-mnemonic-etc) in our example, but you can use a WalletClient instance from the [wagmi hook](https://wagmi.sh/react/api/hooks/useWalletClient) or an ethers.js [Signer](https://docs.ethers.org/v6/api/providers/#Signer).

Chose the adapter for the library of your choice:

```
import { signMessageWith } from "@lens-protocol/client/viem";
```

And, use the PublicClient instance you created [earlier](https://lens.xyz/docs/protocol/getting-started/typescript) to log in and acquire a SessionClient instance.

```
import { client } from "./client";import { signer } from "./signer";
const authenticated = await client.login({  onboardingUser: {    app: "0x5678…",    wallet: signer.address,  },  signMessage: signMessageWith(signer),});
if (authenticated.isErr()) {  return console.error(authenticated.error);}
// SessionClient: { ... }const sessionClient = authenticated.value;
```

Use the SessionClient to interact with @lens-protocol/client/actions that require authentication.

The @lens-protocol/client/actions that require authentication are explicitly
labelled by the type of client they accept as first argument.

## List Available Accounts

Often, when you are about to log in with an Account, you may want to list the available Accounts for the user's wallet.

- TypeScript
- GraphQL
- React

Use the paginated fetchAccountsAvailable action to list the Accounts available for the given wallet address.

```
import { evmAddress } from "@lens-protocol/client";import { fetchAccountsAvailable } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await fetchAccountsAvailable(client, {  managedBy: evmAddress("0x1234…"),  includeOwned: true,});
```

Continue with the [Pagination](https://lens.xyz/docs/protocol/best-practices/pagination) guide for more information on how to handle paginated results.

See the [Account Manager](https://lens.xyz/docs/protocol/accounts/manager) guide for more information on
how to manage accounts.

## Manage Sessions

Once you have successfully authenticated, you can manage your authenticated sessions by:

- Keeping your session alive

- Getting details about the current session

- Listing all authenticated sessions


### Keep Alive

- TypeScript
- GraphQL
- React

#### Resume Session

By default, the PublicClient uses in-memory storage for the storing the authenticated session, which is lost when the current thread closes, like when refreshing a page in a browser. To keep the session persistent, supply a long-term storage solution to the PublicClient config.

In a browser, for instance, you could use the [Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API) like window.localStorage:

```
import { PublicClient, mainnet } from "@lens-protocol/client";
const const client = PublicClient.create({  environment: mainnet
  storage: window.localStorage,});
```

Then resume an authenticated SessionClient from long-term storage like so:

```
import { client } from "./client";
const resumed = await client.resumeSession();
if (resumed.isErr()) {  return console.error(resumed.error);}
// SessionClient: { ... }const sessionClient = resumed.value;
```

The SessionClient instance is now ready to be used for authenticated requests.

### Get Current Session

- TypeScript
- GraphQL
- React

Use the currentSession action:

```
import { currentSession } from "@lens-protocol/client/actions";
```

to get details about the current session.

```
const result = await currentSession(sessionClient);
if (result.isErr()) {  return console.error(result.error);}
// AuthenticatedSession: { authenticationId: UUID, app: EvmAddress, ... }const session = result.value;
```

### List Authenticated Sessions

- TypeScript
- GraphQL
- React

Use the fetchAuthenticatedSessions action:

```
import { fetchAuthenticatedSessions } from "@lens-protocol/client/actions";
```

to get a paginated list of all authenticated sessions.

```
const result = await fetchAuthenticatedSessions(sessionClient);
if (result.isErr()) {  return console.error(result.error);}
// Array<AuthenticatedSession>: [{ authenticationId: UUID, app: EvmAddress, ... }, ... ]const sessions = result.value.items;
```

See the [Pagination](https://lens.xyz/docs/protocol/best-practices/pagination) guide for more information on how to handle paginated results.

## Log Out

You MUST be authenticated as Account Owner or Account Manager to make this
request.

- TypeScript
- GraphQL
- React

Use the client.logout method to revoke any authenticated session and clear any client state.

```
const result = await client.logout();
```

## Get Last Logged-In Account

A simple way to fetch a user's last Lens account login, helping returning users quickly identify and access their previous account before authentication is required.

- TypeScript
- GraphQL
- React

Use the lastLoggedInAccount action to get the last logged-in account.

```
import { evmAddress } from "@lens-protocol/client";import { lastLoggedInAccount } from "@lens-protocol/client/actions";
const result = await lastLoggedInAccount(anyClient, {  address: evmAddress("0x1234…"),});
if (result.isErr()) {  return console.error(result.error);}
```

## Advanced Topics

### Authentication Storage

If you need to store authentication tokens in a custom storage solution with the Lens SDK, implement the IStorageProvider interface.

```
interface IStorageProvider {  getItem(key: string): Promise<string | null> | string | null;
  setItem(    key: string,    value: string  ): Promise<string> | Promise<void> | void | string;
  removeItem(key: string): Promise<string> | Promise<void> | void;}
```

For example, you can use the cookie-next library for Next.js to store and pass the authentication tokens between client and server of a Next.js application.

```
import { getCookie, setCookie, deleteCookie } from "cookies-next";import { IStorageProvider } from "@lens-protocol/client";
export const storage: IStorageProvider = {  getItem(key: string) {    return getCookie(key) ?? null;  },
  setItem(key: string, value: string) {    await setCookie(key, value);  },
  removeItem(key: string) {    await deleteCookie(key);  },};
```

### Authentication Tokens

Lens API uses [JSON Web Tokens](https://jwt.io/introduction) (JWT) as format for Token-Based authentication.

On successful authentication, Lens API issues three tokens:

- Access Token

- ID Token

- Refresh Token


Lens JWTs are signed with the RS256 algorithm and can be verified using JSON Web Key Sets (JWKS) from the /.well-known/jwks.json endpoint on the corresponding Lens API environment:

- Mainnet: https://api.lens.xyz/.well-known/jwks.json

- Testnet: https://api.testnet.lens.xyz/.well-known/jwks.json


Signing keys could be rotated at any time. Make sure to cache the JWKS and
update it periodically.

#### Access Token

Access Tokens are used to authenticate a user's identity when making requests to the Lens API.

The Access Token is required in the Authorization or x-access-token header for all authenticated requests to the Lens API.

```
# or
```

DO NOT share the Access Token with anyone. Keep it secure and confidential. If
you are looking to identify a user's request on a backend service, use the [ID\\
Token](https://lens.xyz/docs/protocol/authentication#authentication-tokens-id-token) instead.

Lens Access Tokens are valid for **10 minutes** from the time of issuance.

#### Refresh Token

A Refresh Token is a credential artifact used to obtain a new authentication tokens triplet without user interaction. This allows for a shorter Access Token lifetime for security purposes without involving the user when the access token expires. You can request new authentication tokens until the refresh token is added to a denylist or expires.

DO NOT share the Refresh Token with anyone. Keep it secure and confidential,
possibly on the client-side only. If you are looking to perform an operation
in behalf of an Account, use the [Account Manager](https://lens.xyz/docs/protocol/accounts/manager) feature
instead.

Lens Refresh Tokens are valid for **7 days** from the time of issuance.

#### ID Token

The ID Token is used to verify the user's identity on consumer's side. It contains a set of claims about the user and is signed by the Lens API.

Lens ID Tokens are valid for **10 minutes** from the time of issuance, same as the Access Token.

You can use the ID Token to verify the user's identity on a backend service
like described in the [Consume Lens ID\\
Tokens](https://lens.xyz/docs/protocol/authentication#advanced-topics-consume-lens-id-tokens) section.

### Consume Lens ID Tokens

As briefly mentioned earlier, Lens ID Tokens can be used to verify's user identity on a backend service.

Lens ID Tokens are issued with the following claims:

| Claim | Description |  |
| --- | --- | --- |
| sub | Subject - the signedBy address used to sign the Authentication Challenge. This could be the Account or an Account Manager for it. Example: 0xC47Cccc2bf4CF2635a817C01c6A6d965045b06e6. |  |
| iss | Issuer - the Lens API endpoint that issued the token. Typically: https://api.lens.xyz. |  |
| aud | Audience - the Lens App address that the token is intended for. Example: 0x00004747f7a56EE7Af7237220c960a7D06232626. |  |
| iat | Issued At - the timestamp when the token was issued. |  |
| exp | Expiration - the timestamp indicating when the token will expire. This can be used to determine if the token is still valid. |  |
| sid | Session ID - the unique identifier of the session that the token was issued for. |  |
| act | Optional claim that allows the token to act on behalf of another Account. This is useful for Account Managers to specify the Account address they can act on behalf of. |  |
| tag:lens.dev,2024:sponsored | Custom claim that indicates the authenticated session is enabled for sponsored transactions. |  |
| tag:lens.dev,2024:role | Custom claim that indicates the role of the authenticated session. Possible values are ACCOUNT\_OWNER, ACCOUNT\_MANAGER, ONBOARDING\_USER, and BUILDER. |  |

A typical use case is to use Lens issued ID Token to verify the legitimacy of user's request before issuing your app specific credentials. The following diagram illustrates this flow:

Your Backend ServiceLens APIUserYour Backend ServiceLens APIUserCaches JWKSLater on…Verify Lens ID Tokenw/ cached JWKSFetch /.well-known/jwks.jsonJWKSAuthenticateIssues ID TokenAuthenticate w/ Lens ID TokenIssues app credentials

Below is an example of a [Next.js middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware) that demonstrates how to verify a Lens ID Token using the popular [jose](https://www.npmjs.com/package/jose) library:

```
import { NextResponse } from "next/server";import { jwtVerify, createRemoteJWKSet } from "jose";
// Get JWKS URI from environment variablesconst jwksUri = process.env.NEXT_PUBLIC_JWKS_URI;const JWKS = createRemoteJWKSet(new URL(jwksUri));
export async function middleware(req) {  const token = req.headers.get("authorization")?.split(" ")[1];
  if (!token) {    return new NextResponse(      JSON.stringify({ error: "Authorization token missing" }),      {        status: 401,        headers: { "Content-Type": "application/json" },      }    );  }
  try {    // Verify the JWT using the JWKS    const { payload } = await jwtVerify(token, JWKS);
    // Optionally, attach the payload to the request    req.user = payload;
    // Proceed to the API route    return NextResponse.next();  } catch (error) {    console.error("JWT verification failed:", error);    return new NextResponse(      JSON.stringify({ error: "Invalid or expired token" }),      {        status: 401,        headers: { "Content-Type": "application/json" },      }    );  }}
export const config = {  matcher: ["/api/:path*"],};
```

The example works under the following assumptions:

- The Lens ID Token is passed in the Authorization header as a Bearer token (e.g., Authorization: Bearer <ID Token>).

- The JWKS URI is available in the NEXT\_PUBLIC\_JWKS\_URI environment variable.

- Your API routes are located under the /api path.


Adapt it to your specific use case as needed.

You can now use the req.user object in your API routes to access the user's identity.

```
export default function handler(req, res) {  // The JWT payload will be available as req.user if the token is valid  if (req.user) {    return res.status(200).json({ message: "Success", user: req.user });  } else {    return res.status(401).json({ error: "Unauthorized" });  }}
```

[Previous\\
\\
**React**](https://lens.xyz/docs/protocol/getting-started/react) [Next\\
\\
**Apps**](https://lens.xyz/docs/protocol/apps)

## Fetch Usernames Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Fetch Usernames

This guide will help you with fetching Usernames from Lens API.

## Fetch a Username

- TypeScript
- GraphQL
- React

Use the fetchUsername function to fetch a single username by localName or ID.

```
import { fetchUsername } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await fetchUsername(client, {  username: {    localName: "alice",    // namespace: evmAddress("0x1234…"), - optional for custom namespaces  },});
if (result.isErr()) {  return console.error(result.error);}
// { ID: string, value: string, linkedTo: evmAddress, owner: evmAddress, ... }const username = result.value;
```

## List Usernames

- TypeScript
- GraphQL
- React

Use the paginated fetchUsernames action to fetch a list of Usernames based on the provided filters.

```
import { fetchUsernames } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await fetchUsernames(client, {  filter: {    localNameQuery: "tom",    // namespace: evmAddress("0x1234…"), - optional for custom namespaces  },});
if (result.isErr()) {  return console.error(result.error);}
// items: Array<Username>const { items, pageInfo } = result.value;
```

See the [Pagination](https://lens.xyz/docs/protocol/best-practices/pagination) guide for more information on how to handle paginated results.

[Previous\\
\\
**Create Usernames**](https://lens.xyz/docs/protocol/usernames/create) [Next\\
\\
**Assigning Usernames**](https://lens.xyz/docs/protocol/usernames/assign)

## Custom Feeds Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Custom Feeds

This guide will introduce the concept of Custom Feeds and how to create and manage them.

As mentioned in the [Feed](https://lens.xyz/docs/concepts/feed) concept page, there are two classes of Feed instances:

- **The Global Feed**: The familiar shared feed that aggregates all public Lens activity.

- **Custom Feeds**: App or group-specific feeds that can be open or governed by [Feed Rules](https://lens.xyz/docs/protocol/feeds/rules).


## Create a Custom Feed

To create a Custom Feed, follow these steps.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) to create a Feed.

1

### Create Metadata

First, construct a Feed Metadata object with the necessary content.

- TS/JS
- JSON Schema

Use the @lens-protocol/metadata package to construct a valid FeedMetadata object:

```
import { feed } from "@lens-protocol/metadata";
const metadata = feed({  name: "XYZ",  description: "My custom feed description",});
```

2

### Upload Metadata

Next, upload the Feed Metadata object to a public URI.

```
import { storageClient } from "./storage-client";
const { uri } = await storageClient.uploadAsJson(metadata);
console.log(uri); // e.g., lens://4f91ca…
```

This example uses [Grove storage](https://lens.xyz/docs/storage) to host the Metadata object.
See the [Lens Metadata\\
Standards](https://lens.xyz/docs/protocol/best-practices/metadata-standards#host-metadata-objects) guide
for more information on hosting Metadata objects.

3

### Deploy Feed Contract

Next, deploy the Lens Feed smart contract.

- TypeScript
- GraphQL
- React

Use the createFeed action to deploy the Lens Feed smart contract.

```
import { uri } from "@lens-protocol/client";import { createFeed } from "@lens-protocol/client/action";
const result = await createFeed(sessionClient, {  metadataUri: uri("lens://4f91ca…"),});
```

To learn more about how to use Feed Rules, see the [Feed Rules](https://lens.xyz/docs/protocol/feeds/feed-rules) guide.

4

### Handle Result

- TypeScript
- GraphQL
- React

Finally, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await createFeed(sessionClient, {  metadataUri: uri("lens://4f91ca…"),}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Fetch a Feed

- TypeScript
- GraphQL
- React

Use the fetchFeed action to fetch a single Feed by address or by transaction hash.

```
import { evmAddress } from "@lens-protocol/client";import { fetchFeed } from "@lens-protocol/client/actions";import { client } from "./client";
const result = await fetchFeed(client, {  address: evmAddress("0x1234…"),});
if (result.isErr()) {  return console.error(result.error);}
const feed = result.value;
```

## Search Feeds

- TypeScript
- GraphQL
- React

Use the paginated fetchFeeds action to search for feeds.

```
import { fetchFeeds } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await fetchFeeds(client, {  filter: {    searchBy: "feedName",  },});
if (result.isErr()) {  return console.error(result.error);}
// items: Array<Feed>const { items, pageInfo } = result.value;
```

Continue with the [Pagination](https://lens.xyz/docs/protocol/best-practices/pagination) guide for more information on how to handle paginated results.

## Access Control

The Feed contract supports two roles: _Owner_ and _Administrator_.

Administrators can:

- Update the Feed Metadata

- Update the Feed Rules

- Update the Feed Extra Data


The Owner can do everything the administrators can do, plus transfer ownership of the Feed to another address.

See the [Team Management](https://lens.xyz/docs/protocol/best-practices/team-management) guide for more information on how to manage these roles.

[Previous\\
\\
**Post Rules**](https://lens.xyz/docs/protocol/feeds/post-rules) [Next\\
\\
**Feed Rules**](https://lens.xyz/docs/protocol/feeds/feed-rules)

## Lens Metadata Standards
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Metadata Standards

This guide explain how Metadata objects are created and managed in Lens.

Lens Metadata Standards, introduced in [LIP-2](https://github.com/lens-protocol/LIPs/pull/5), are a set of **self-describing object specifications**. These standards ensure that the data includes all the necessary information for validation within itself.

## Create Metadata Object

You can construct Metadata objects in two ways:

- By utilizing the @lens-protocol/metadata package

- Manually, with the help of a dedicated JSON Schema


- TS/JS
- JSON Schema

Install the @lens-protocol/metadata package with its required peer dependencies.

```
npm install zod @lens-protocol/metadata@latest
```

Below, we provide few practical examples for creating Metadata objects. Throughout this documentation, we will detail the specific Metadata objects required for various use cases.

```
import { textOnly } from "@lens-protocol/metadata";
const metadata = textOnly({  content: `GM! GM!`,});
```

## Host Metadata Objects

We recommend using [Grove](https://lens.xyz/docs/storage) to host your Metadata objects as a cheap and secure solution. However, developers are free to store Metadata anywhere, such as IPFS, Arweave, or AWS S3, as long as the data is publicly accessible via a URI and served with the Content-Type: application/json header.

In this documentation, examples will often use an instance of Grove's StorageClient to upload Metadata objects.

```
import { StorageClient, testnet } from "@lens-chain/storage-client";
export const storageClient = StorageClient.create(testnet);
```

You can also upload media files to the same hosting solution, then reference
their URIs in the Metadata prior to uploading it.

## Query Metadata Media

Many metadata fields reference media objects such as images, audio, and video files. The content at those URIs is fetched and snapshotted by the Lens API as part of the indexing process.

By default, when you query those fields, the Lens API returns the snapshot URLs. However, you can also request the original URIs.

```
fragment MediaImage on MediaImage {  __typename  altTag  item # Snapshot URL  original: item(request: { useOriginal: true })  license  type  width  height}
```

Additionally, when you get snapshot URLs of images, you can request different sizes of the image through an ImageTransform object.

```
input ImageTransform @oneOf {  fixedSize: FixedSizeTransform  widthBased: WidthBasedTransform  heightBased: HeightBasedTransform}
# Resize image to a fixed size, cropping if necessaryinput FixedSizeTransform {  width: Int! # px  height: Int! # px}
# Maintain aspect ratio by adjusting height based on widthinput WidthBasedTransform {  width: Int! # px}
# Maintain aspect ratio by adjusting width based on heightinput HeightBasedTransform {  height: Int! # px}
```

See the following example:

```
fragment MediaImage on MediaImage {  # …
  tall: item(request: { preferTransform: { heightBased: { height: 600 } } })
  large: item(request: { preferTransform: { widthBased: { witdh: 2048 } } })
  thumbnail: item(    request: { preferTransform: { fixedSize: { height: 128, witdh: 128 } } }  )}
```

## Refresh Metadata Objects

In some cases, you may need to refresh the cached content of a Metadata object in the Lens API.

Let's go through an example. Suppose you have a Post object with a Metadata object hosted on [Grove](https://lens.xyz/docs/storage) that you want to update without submitting a transaction, as described in the [edit Post guide](https://lens.xyz/docs/protocol/feeds/edit-post).

```
import { Post } from "@lens-protocol/client";
const post: Post = {  id: "42",  contentUri: "lens://323c0e1cceb…",  metadata: {    content: "Good morning!",  },
  // …};
```

Assuming you have the [necessary permissions](https://lens.xyz/docs/storage/usage/upload#permission-models) to update the content of the Post, you can update the Metadata object hosted on Grove as follows.

```
import { textOnly } from "@lens-protocol/metadata";
import { acl } from "./acl";import { storageClient } from "./storage";import { signer } from "./viem";
const updates = textOnly({  content: `Good morning!`,});
const response = await storageClient.updateJson(  post.contentUri  newData,  signer,  { acl });
```

The process described here works with any hosting solution that allows you to
update the content at a given URI.

- TypeScript

1

### Initiate a Metadata Refresh

First, use the refreshMetadata action to initiate the refresh process.

```
import { refreshMetadata } from "@lens-protocol/client";import { client } from "./client";
const result = await refreshMetadata(client, { entity: { post: post.id } });
```

This process is asynchronous and may take a few seconds to complete.

2

### Wait for the Refresh to Complete

Then, if necessary, use the for the Lens API to update the Metadata object.

```
import { waitForMetadata } from "@lens-protocol/client";
// …
const result = await refreshMetadata(client, {  entity: { post: post.id },}).andThen(({ id }) => waitForMetadata(client, id));
```

That's it—any Lens API request involving the given Post will now reflect the updated Metadata object.

[Previous\\
\\
**Fetch Sponsorships**](https://lens.xyz/docs/protocol/sponsorships/fetch) [Next\\
\\
**Team Management**](https://lens.xyz/docs/protocol/best-practices/team-management)

## Lens Protocol Apps
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Page not found.

Sorry. The page you're looking for can't be found.

Back to home

## Follow Rules Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Follow Rules

This guide explains how to use Follow Rules and how to implement custom ones.

Follow Rules allow [accounts](https://lens.xyz/docs/concepts/account) to add requirements or constraints that will be applied when another account tries to Follow them.

## Using Follow Rules

Users have the option to apply Follow Rules to their accounts. These rules dictates the conditions under which another account can Follow them.

For [Custom Graphs](https://lens.xyz/docs/protocol/graphs/custom-graphs), these rules work in combination with [Graph Rules](https://lens.xyz/docs/protocol/graphs/graph-rules) set on the given graph.

This section presumes you are familiar with the process of [following an\\
Account](https://lens.xyz/docs/protocol/graphs/follow-unfollow) on Lens.

### Built-in Follow Rules

#### Simple Payment Follow Rule

The SimplePaymentFollowRule is a built-in rule that can be applied to an Account within the context of a specific Graph. It requires an ERC-20 payment from any Account attempting to follow it in order for the operation to succeed.

A **1.5%** Lens treasury fee is deducted from the payment before the remaining
amount is transferred to the designated recipient.

#### Token Gated Follow Rule

The TokenGatedFollowRule is a built-in rule that can be applied to an Account within the context of a specific Graph. It requires any other Account attempting to follow it to hold a certain balance of a token (both fungible and non-fungible are supported).

### Update Follow Rules

You MUST be authenticated as Account Owner or Account Manager of the Account
you intend to update the Follow Rules for.

1

#### Submit Update Request

First, prepare the update request with the new Follow Rules configuration.

- TypeScript
- GraphQL
- React

Use the updateAccountFollowRules action to update the Follow Rules for the logged-in Account.

```
import { bigDecimal, evmAddress } from "@lens-protocol/client";import { updateAccountFollowRules } from "@lens-protocol/client/actions";
const result = await updateAccountFollowRules(sessionClient, {  toAdd: {    required: [      {        simplePaymentRule: {          cost: {            currency: evmAddress("0x5678…"),            value: bigDecimal("10.42"),          },          recipient: evmAddress("0x9012…"),        },      },    ],  },});
if (result.isErr()) {  return console.error(result.error);}
```

2

#### Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await updateAccountFollowRules(sessionClient, {  // …}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Building a Follow Rule

Let's illustrate the process with an example. We will build a custom Follow Rule that once applied it will only accept Follows from accounts that you previously Followed in some Graph (particularly, the same Graph where the rule is applied can be used, so only the accounts that you Follow will be able to Follow you back).

To build a custom Follow Rule, you must implement the following IFollowRule interface:

```
interface IFollowRule {    function configure(bytes32 configSalt, address account, KeyValue[] calldata ruleParams) external;
    function processFollow(        bytes32 configSalt,        address originalMsgSender,        address followerAccount,        address accountToFollow,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external;}
```

Each function of this interface must assume to be invoked by the Graph contract where the rule is applied. In other words, assume the msg.sender will be the Graph contract.

A Lens dependency package with all relevant interfaces will be available soon.

1

### Implement the Configure Function

First, implement the configure function. This function initializes any required state for the rule to work correctly for a specific account on a specific graph configuration.

It receives three parameters:

- configSalt: A 32-byte value allowing the same rule contract to be used multiple times with different configurations for the same account within the same graph. The triple (Graph Address, Account Address, Configuration Salt) identifies a unique rule configuration instance.

- account: The address of the account for which this rule is being configured for.

- ruleParams: An array of key-value pairs that can be used to pass any custom configuration parameters to the rule. Each key is bytes32, we put the hash of the parameter name there, and each value is bytes, we set the ABI-encoded parameter value there. Given that ruleParams is an array, this allows the rule to define which parameters are optional and which are required, acting accordingly when any of them are not present.


The configure function can be called multiple times by the same Graph, passing the same account and configSalt, to update an existing rule configuration (i.e., reconfigure it).

In our example, we need to configure which Graph should be checked to see if the accountToFollow is already following the followerAccount. We'll decode an address parameter representing this target Graph.

Let's define a storage mapping to store this configuration:

```
contract AlreadyFollowedFollowRule is IFollowRule {    mapping(address graph => mapping(bytes32 configSalt => mapping(address account => address graph))) _graphToCheck;}
```

The configuration parameters are stored using the Graph contract address (msg.sender), the configSalt, and the account as keys. This allows the same rule contract to be reused across different Graphs and Accounts as several times.

Now let's code the configure function, decoding the target graph address from ruleParams:

```
contract AlreadyFollowedFollowRule is IFollowRule {    mapping(address graph => mapping(bytes32 configSalt => mapping(address account => address graph))) _graphToCheck;
    function configure(bytes32 configSalt, address account, KeyValue[] calldata ruleParams) external override {        address graph;        for (uint256 i = 0; i < ruleParams.length; i++) {            if (ruleParams[i].key == keccak256("lens.param.graph")) {                graph = abi.decode(ruleParams[i].value, (address));                break;            }        }
        // A call to check if the address holds a valid Graph        IGraph(graph).isFollowing(address(this), address(account));
        _graphToCheck[msg.sender][configSalt][account] = graph;    }}
```

Here, we made the graph a required parameter, given that when it is not present it will be address(0) and then revert on the isFollowing call.

2

### Implement the Process Follow Function

Next, implement the processFollow function. This function is invoked by the Graph contract every time a Follow is executed, so then the rule logic can be applied to shape under which conditions this operation can succeed.

The function receives:

- configSalt: Identifies the specific rule configuration instance.

- originalMsgSender: The address that invoked the follow function in the Graph contract.

- followerAccount: The account taking the role of follower.

- accountToFollow: The account that is being followed, which is the one the rule was configured for.

- primitiveParams: Additional parameters that were passed to the Graph's follow function call.

- ruleParams: Additional parameters specific to this rule execution.


For our example, we need to:

1. Retrieve the configured graph to check.

2. Check if accountToFollow is already following followerAccount on that graph.

3. Revert if the accountToFollow is not already following the followerAccount on that graph.


The IGraph interface contains this function in order to check whether an account is following another account or not:

```
function isFollowing(        address followerAccount,        address targetAccount    ) external view returns (bool);
```

Let's see how each step looks like in code:

```
contract AlreadyFollowedFollowRule is IFollowRule {    mapping(address graph => mapping(bytes32 configSalt => mapping(address account => address graph))) _graphToCheck;
    // ...
    function processFollow(        bytes32 configSalt,        address originalMsgSender,        address followerAccount,        address accountToFollow,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external view override {        // Retrieve the configured graph to check        IGraph graphToCheck = _graphToCheck[msg.sender][configSalt][accountToFollow];
        // Check if `accountToFollow` is already following `followerAccount` on that graph        bool isFollowedBack = graphToCheck.isFollowing(accountToFollow, followerAccount);
        // Revert if the `accountToFollow` is not already following the `followerAccount` on that graph        require(isFollowedBack);    }}
```

Now the AlreadyFollowedFollowRule is ready to be applied to any account under any Graph that supports Follow Rules. See the full code below:

```
contract AlreadyFollowedFollowRule is IFollowRule {    mapping(address graph => mapping(bytes32 configSalt => mapping(address account => address graph))) _graphToCheck;
    function configure(bytes32 configSalt, address account, KeyValue[] calldata ruleParams) external override {        address graph;        for (uint256 i = 0; i < ruleParams.length; i++) {            if (ruleParams[i].key == keccak256("lens.param.graph")) {                graph = abi.decode(ruleParams[i].value, (address));                break;            }        }
        // A call to check if the address holds a valid Graph        IGraph(graph).isFollowing(address(this), address(account));
        _graphToCheck[msg.sender][configSalt][account] = graph;    }
    function processFollow(        bytes32 configSalt,        address originalMsgSender,        address followerAccount,        address accountToFollow,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external view override {        // Retrieve the configured graph to check        IGraph graphToCheck = _graphToCheck[msg.sender][configSalt][accountToFollow];
        // Check if `accountToFollow` is already following `followerAccount` on that graph        bool isFollowedBack = graphToCheck.isFollowing(accountToFollow, followerAccount);
        // Revert if the `accountToFollow` is not already following the `followerAccount` on that graph        require(isFollowedBack);    }}
```

Stay tuned for API integration of rules and more guides!

[Previous\\
\\
**Follow Relationships**](https://lens.xyz/docs/protocol/graphs/relationships) [Next\\
\\
**Custom Graphs**](https://lens.xyz/docs/protocol/graphs/custom-graphs)

## Create Lens Account
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Create an Account

This guide will help you create your first Lens account.

To create a new Account, follow these steps

1

## Log In as Onboarding User

First, authenticate as an [Onboarding User](https://lens.xyz/docs/protocol/authentication).

The process is explained in detail in the [Authentication](https://lens.xyz/docs/protocol/authentication)
guide, so we will keep it brief here.

- TypeScript
- GraphQL
- React

Use the @lens-protocol/client package to authenticate as an Onboarding User:

```
import { client } from "./client";
const authenticated = await client.login({  onboardingUser: {    app: "0xaC19aa2402b3AC3f9Fe471D4783EC68595432465",    wallet: signer.address,  },  signMessage: (message) => signer.signMessage({ message }),});
if (authenticated.isErr()) {  return console.error(authenticated.error);}
// SessionClient: { ... }const sessionClient = authenticated.value;
```

2

## Create Account Metadata

Then, construct a new Account Metadata object with the necessary details.

- TS/JS
- JSON Schema

Use the @lens-protocol/metadata package to construct a valid AccountMetadata object:

```
import { MetadataAttributeType, account } from "@lens-protocol/metadata";
const metadata = account({  name: "Jane Doe",  bio: "I am a photographer based in New York City.",  picture: "lens://4f91cab87ab5e4f5066f878b72…",  coverPicture: "lens://4f91cab87ab5e4f5066f8…",  attributes: [    {      key: "twitter",      type: MetadataAttributeType.STRING,      value: "https://twitter.com/janedoexyz",    },    {      key: "dob",      type: MetadataAttributeType.DATE,      value: "1990-01-01T00:00:00Z",    },    {      key: "enabled",      type: MetadataAttributeType.BOOLEAN,      value: "true",    },    {      key: "height",      type: MetadataAttributeType.NUMBER,      value: "1.65",    },    {      key: "settings",      type: MetadataAttributeType.JSON,      value: '{"theme": "dark"}',    },  ],});
```

See the [Lens Metadata Standards](https://lens.xyz/docs/protocol/best-practices/metadata-standards) guide
for more information on creating and hosting Metadata objects.

3

## Upload Account Metadata

Then, upload the Account Metadata object to a public URI.

```
import { account } from "@lens-protocol/metadata";import { storageClient } from "./storage-client";
const metadata = account({  name: "Jane Doe",});
const { uri } = await storageClient.uploadAsJson(metadata);
console.log(uri); // e.g., lens://4f91ca…
```

This example uses [Grove storage](https://lens.xyz/docs/storage) to host the Metadata object.
See the [Lens Metadata\\
Standards](https://lens.xyz/docs/protocol/best-practices/metadata-standards#host-metadata-objects) guide
for more information on hosting Metadata objects.

4

## Deploy Account Contract

Remember you MUST be authenticated as [Onboarding User](https://lens.xyz/docs/protocol/authentication) to
make this request.

- TypeScript
- GraphQL
- React

Then, you can use the createAccountWithUsername action to deploy Lens Account smart contract and contextually mint a username for it.

```
import { uri } from "@lens-protocol/client";import { createAccountWithUsername } from "@lens-protocol/client/action";
const result = await createAccountWithUsername(sessionClient, {  username: { localName: "wagmi" },  metadataUri: uri("lens://4f91ca…"),});
```

The Lens SDK example here leverages a functional approach to chaining
operations using the Result<T, E> object. See the [Error\\
Handling](https://lens.xyz/docs/protocol/best-practices/error-handling) guide for more
information.

5

## Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await createAccountWithUsername(sessionClient, {  username: { localName: "wagmi" },  metadataUri: uri("lens://4f91ca…"),})  .andThen(handleOperationWith(walletClient))  .andThen(sessionClient.waitForTransaction);
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

6

## Switch to Account Owner

Finally, switch to the [Account Owner](https://lens.xyz/docs/protocol/authentication) authentication role to access the newly created Account.

- TypeScript
- GraphQL
- React

Use the fetchAccount action to retrieve the newly created Account.

```
import { fetchAccount } from "@lens-protocol/client/actions";
// …
const result = await createAccountWithUsername(sessionClient, {  username: { localName: "wagmi" },  metadataUri: uri("lens://4f91ca…"),})  .andThen(handleOperationWith(walletClientOrSigner))  .andThen(sessionClient.waitForTransaction);  .andThen((txHash) => fetchAccount(sessionClient, { txHash }));
```

And, use the SessionClient.switchAccount method to switch to the new Account as the Account Owner.

```
import { never } from "@lens-protocol/client";
// …
const result = await createAccountWithUsername(sessionClient, {  username: { localName: "wagmi" },  metadataUri: uri("lens://4f91ca…"),})  .andThen(handleOperationWith(walletClientOrSigner))  .andThen(sessionClient.waitForTransaction);  .andThen((txHash) => fetchAccount(sessionClient, { txHash }))  .andThen((account) =>    sessionClient.switchAccount({      account: account?.address ?? never("Account not found"),    })  );
```

That's it—you are now authenticated with the newly created Account.

[Previous\\
\\
**Authorization Workflows**](https://lens.xyz/docs/protocol/apps/authorization-workflows) [Next\\
\\
**Fetch Accounts**](https://lens.xyz/docs/protocol/accounts/fetch)

## Lens Migration Overview
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Migration Overview

This guide provides a high-level overview of the paradigm shifts between Lens v2 and Lens v3.

## Data Migration

Most of the Lens v2 data was migrated from Polygon to Lens v3 on the Lens Chain Mainnet. The migrated data included:

- Profiles were migrated into Accounts

- Signless configuration

- Profile Managers were migrated into Account Managers

- Handles were migrated into Usernames

- App IDs defined in metadata were migrated as onchain App Primitives

- Follow relationships into the Lens Global Graph

- Publications:


- All root posts were migrated.

- Comments were migrated up to 4 levels deep — comments on a comment on a comment on a comment were included.

- Only quotes of root posts were migrated; quotes of comments were excluded.


As of **April 3, 2025**, migration data from Lens v2 to Lens v3 has been
synchronized up to **Polygon block**
**[69,837,653](https://polygonscan.com/block/69837653)**.

## Exiting Concepts

- **Profile → Account** – In Lens v2, Profiles were stored as state within a single smart contract. In Lens v3, each Account is its own smart contract.

- **Profile Manager → Account Manager** – In v3, management is built directly into the Account contract itself.

- **Handle → Username** – Handles are now called usernames. Users can have multiple usernames across different namespaces.

- **Follow Modules → Follow Rules** – Follow modules are now referred to as follow rules.

- **Reference Modules → Post Rules** – Similarly, reference modules are now called post rules.

- **App ID → Onchain App Primitives** – In v3, apps are fully onchain, unlocking powerful new capabilities.

- **Gasless → Sponsorships** – Apps now create sponsorships for their users and decide who receives them.


Lens V3 automatically migrated accounts and usernames for users. If a Safe was
used, it was deployed on the user's behalf. However, if the account or
username was owned by contract on Polygon, it could not be transferred
automatically. If this applies to you, please contact us — we can help
transfer ownership once verification is complete.

## New Concepts

You can explore the full documentation to learn about the new concepts introduced in Lens v3. We recommend starting with the [Overview](https://lens.xyz/docs/protocol/index).

## Deprecated Concepts

- **Profile Guardian** – In v3, Accounts have owners in a more standard smart wallet pattern.

- **Handle Guardian** – There is no equivalent concept in v3.


[Previous\\
\\
**Transaction Lifecycle**](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) [Next\\
\\
**SDK**](https://lens.xyz/docs/protocol/migration/sdk)

## Lens Group Feature
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

Foodies8,225 membersJoinedCat Rescue3,721 membersJoin$2,101Virtual City921 membersJoined

# Group

The Group feature on Lens enables the creation of onchain communities with customizable rules and governance.
Each group is a smart contract that can be linked to applications, allowing for tight integration between user groups and the platforms they interact with.
Groups can set join rules using the modular rule system—for instance, requiring members to own a certain token or NFT, or to pay a fee to join.
This flexibility allows groups to tailor their membership criteria to their specific needs.

Members can participate in dedicated group feeds, fostering focused discussions and content sharing.
Admins have control over membership, including the ability to ban or remove members, and can set up group-specific usernames and even associate an ERC20 token with the group.
Metadata settings allow communities to define their purpose and guidelines clearly, enhancing transparency and cohesion among members.

[Previous\\
\\
**App**](https://lens.xyz/docs/protocol/concepts/app) [Next\\
\\
**Feed**](https://lens.xyz/docs/protocol/concepts/feed)

## Lens API Pagination Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Paginated Results

This guide explains hot to handle paginated results in Lens.

Lens API uses cursor-based pagination to navigate through lists of results. This is crucial for both performance and user experience, as it allows the API to return only the data required at a given time.

## Paginated Responses

- TypeScript
- GraphQL

With T representing the item type being queried, all paginated queries yield a Paginated<T> object:

```
type Paginated<T> = {  items: readonly T[];  pageInfo: PaginatedResultInfo;};
```

where items contains the current page of results and pageInfo contains information about the pagination state:

- TypeScript
- GraphQL

```
type PaginatedResultInfo = {  prev: Cursor | null;  next: Cursor | null;};
```

The Cursor type is an _opaque_ scalar that can be used to fetch a different page of results.

## Paginated Requests

All paginated queries accepts two optional parameters: pageSize and cursor.

- TypeScript
- GraphQL

```
type Request = {  cursor?: Cursor | null;  pageSize?: PageSize | null;};
```

where

- pageSize determines the number of items to return per page.

- cursor is the value of the next or prev field from a previous response.


The meaning of _prev_ and _next_ depends on the query and the sorting order.
For example, when sorting by creation date with most recent first, _prev_ will
return newer items and _next_ will return older items.

## Examples

Let's use an example to illustrate how to handle paginated results.

1

### First Page

- TypeScript
- GraphQL
- React

Let's say you want to fetch the paginated posts by a specific author:

```
import { evmAddress } from "@lens-protocol/client";import { fetchPosts } from "@lens-protocol/client/actions";
const page1 = await fetchPosts(sessionClient, {  filter: {    authors: [evmAddress("0x1234…")],  },  pageSize: PageSize.FIFTY,});
if (page1.isErr()) {  return console.error(page1.error);}
const { items, pageInfo } = page1.value;
```

The result value will contain the first page of posts and a pageInfo.next cursor:

2

### Next Pages

- TypeScript
- GraphQL
- React

Use the pageInfo.next cursor to fetch the next page of posts:

```
const page2 = await fetchPosts(sessionClient, {  filter: {    authors: [evmAddress("0x1234…")],  },  pageSize: PageSize.FIFTY,  cursor: page1.pageInfo.next,});
```

Remember to retain the same search criteria and pageSize of the initial
query when fetching subsequent pages.

That's it—you can apply the same approach to any paginated query in Lens.

[Previous\\
\\
**Custom Fragments**](https://lens.xyz/docs/protocol/best-practices/custom-fragments) [Next\\
\\
**Error Handling**](https://lens.xyz/docs/protocol/best-practices/error-handling)

## Follow and Unfollow Accounts
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Follow and Unfollow

This guide explains how to follow and unfollow an Account on Lens.

Lens Account can follow other Lens accounts on the Global Graph or on [Custom Graphs](https://lens.xyz/docs/protocol/graphs/custom-graphs).

Follow operations are regulated by [Follow Rules](https://lens.xyz/docs/protocol/graphs/follow-rules) set on the target Account and by the [Graph Rule](https://lens.xyz/docs/protocol/graphs/graph-rules) of the Graph where the follow
relationship is established.

## Follow an Account

To follow an Account, implement the following steps.

You MUST be authenticated as Account Owner or Account Manager to follow an
Account.

1

### Check Rules

First, inspect the account.operations field to determine if you can follow an Account.

- TypeScript
- GraphQL

```
type Account = {  __typename: "Account";  address: EvmAddress;
  // …
  operations: LoggedInAccountOperations;};
```

The account.operations.canFollow can assume one of the following values:

```
switch (account.operations.canFollow.__typename) {  case "AccountFollowOperationValidationPassed":    // Follow is allowed    break;
  case "AccountFollowOperationValidationFailed":    // Following is not possible    console.log(account.operations.canFollow.reason);    break;
  case "AccountFollowOperationValidationUnknown":    // Validation outcome is unknown    break;}
```

Where:

- AccountFollowOperationValidationPassed: The logged-in Account can follow the target Account.

- AccountFollowOperationValidationFailed: Following is not allowed. The reason field explains why. This could be for two reasons:



- The logged-in Account already follows the target Account. In this case, the account.operation.isFollowedByMe field will be true.

- The logged-in Account does not meet the follow criteria for the target Account. In this case, unsatisfiedRules lists the unmet requirements.


- AccountFollowOperationValidationUnknown: The target Account or the Graph (for custom Graphs) has one or more _unknown rules_ requiring ad-hoc verification. The extraChecksRequired field provides the addresses and configurations of these rules.


Treat the AccountFollowOperationValidationUnknown as _failed_ unless you
intend to support the specific rules. See [Follow Rules](https://lens.xyz/docs/protocol/graphs/follow-rules) for
more information.

2

### Submit Follow Request

Then, if your follow request is allowed, you can proceed with submitting the request.

- TypeScript
- GraphQL
- React

Then, use the follow action with the target Account address.

```
import { evmAddress } from "@lens-protocol/client";import { follow } from "@lens-protocol/client/actions";
const result = await follow(sessionClient, { account: evmAddress("0x1234") });
```

The Lens SDK example here leverages a functional approach to chaining
operations using the Result<T, E> object. See the [Error\\
Handling](https://lens.xyz/docs/protocol/best-practices/error-handling) guide for more
information.

3

### Handle Result

- TypeScript
- GraphQL
- React

Finally, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await follow(sessionClient, {  account: evmAddress("0x1234"),}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Unfollow an Account

To unfollow an Account, implement the following steps.

You MUST be authenticated as Account Owner or Account Manager to follow an
Account.

1

### Check Rules

First, inspect the account.operations field to determine if you can unfollow an Account.

- TypeScript
- GraphQL

```
type Account = {  __typename: "Account";  address: EvmAddress;
  // …
  operations: LoggedInAccountOperations;};
```

If true, you can unfollow the account. If false, you might not be following them, in which case the operation.isFollowedByMe field will also be false.

Where:

- AccountFollowOperationValidationPassed: The logged-in Account can unfollow the target Account.

- AccountFollowOperationValidationFailed: Following is not allowed. The reason field explains why. This could be for two reasons:



- The logged-in Account does not follow the target Account. In this case, the account.operation.isFollowedByMe field will be false.

- The logged-in Account does not meet the follow criteria for the target Account. In this case, unsatisfiedRules lists the unmet requirements.


- AccountFollowOperationValidationUnknown: The custom Graph has one or more _unknown rules_ requiring ad-hoc verification. The extraChecksRequired field provides the addresses and configurations of these rules.


Treat the AccountFollowOperationValidationUnknown as _failed_ unless you
intend to support the specific rules. See [Follow Rules](https://lens.xyz/docs/protocol/graphs/follow-rules) for
more information.

2

### Submit Unfollow Request

Then, if your unfollow request is allowed, you can proceed with submitting the request.

- TypeScript
- GraphQL
- React

Then, use the unfollow action with the target Account address.

```
import { evmAddress } from "@lens-protocol/client";import { unfollow } from "@lens-protocol/client/actions";
const result = await unfollow(sessionClient, {  account: evmAddress("0x1234…"),});
```

The Lens SDK example here leverages a functional approach to chaining
operations using the Result<T, E> object. See the [Error\\
Handling](https://lens.xyz/docs/protocol/best-practices/error-handling) guide for more
information.

3

### Handle Result

- TypeScript
- GraphQL
- React

Finally, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await unfollow(sessionClient, {  account: evmAddress("0x1234"),}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

That's it—you now know how to follow and unfollow an Account on Lens, allowing to manage your social graph.

[Previous\\
\\
**Feed Rules**](https://lens.xyz/docs/protocol/feeds/feed-rules) [Next\\
\\
**Follow Relationships**](https://lens.xyz/docs/protocol/graphs/relationships)

## Create Username Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Create Username

This guide explains how to create a new username.

Username issuance is regulated by [Namespace Rules](https://lens.xyz/docs/protocol/usernames/rules) defined on the desired Namespace.

If you’re creating a username under the Global Lens Namespace (i.e., lens/\*), the only restrictions are:

- Allowed characters: a-z, 0-9, -, and \_

- Minimum length: 5 characters

- Must start with a letter or a number


The length of a username is limited to a **maximum of 26 characters on any**
**namespace**.

To create a new username, follow these steps.

You MUST be authenticated as the Account Owner or Account Manager of the
Account that you intend to be the initial owner of the new username.

1

## Verify Availability

First, verify if the desired username is available.

- TypeScript
- GraphQL
- React

Use the canCreateUsername action as follows:

```
import { canCreateUsername } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await canCreateUsername(sessionClient, {  localName: "wagmi",});
if (result.isErr()) {  return console.error(result.error);}
result.value; // CanCreateUsernameResult
```

The CanCreateUsernameResult tells you if the logged-in Account satisfy the Namespace Rules for creating a username, and if the desired username is available.

```
switch (data.__typename) {  case "NamespaceOperationValidationPassed":    // Creating a username is allowed    break;
  case "NamespaceOperationValidationFailed":    // Creating a username is not allowed    console.log(data.reason);    break;
  case "NamespaceOperationValidationUnknown":    // Validation outcome is unknown    break;
  case "UsernameTaken":    // The desired username is not available    break;}
```

Where:

- NamespaceOperationValidationPassed: The logged-in Account can create a username under the desired Namespace.

- NamespaceOperationValidationFailed: Reposting is not allowed. The reason field explains why, and unsatisfiedRules lists the unmet requirements.

- NamespaceOperationValidationUnknown: The Namespace has one or more _unknown rules_ requiring ad-hoc verification. The extraChecksRequired field provides the addresses and configurations of these rules.

- UsernameTaken: The desired username is not available.


Treat the NamespaceOperationValidationUnknown as _failed_ unless you intend
to support the specific rules. See [Namespace Rules](https://lens.xyz/docs/protocol/usernames/rules) for more
information.

To learn more about how to use Namespace Rules, see the [Namespace Rules](https://lens.xyz/docs/protocol/usernames/rules) guide.

2

## Create the Username

Next, if available, create the username.

- TypeScript
- GraphQL
- React

Use the createUsername action to mint the desired username.

```
import { createUsername } from "@lens-protocol/client/actions";
const result = await createUsername(sessionClient, {  username: {    localName: "wagmi",  },});
```

3

## Handle Result

- TypeScript
- GraphQL
- React

Finally, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await createUsername(sessionClient, {  username: {    localName: "wagmi",  },}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

That's it—you have successfully created a new username.

[Previous\\
\\
**Graph Rules**](https://lens.xyz/docs/protocol/graphs/graph-rules) [Next\\
\\
**Fetch Usernames**](https://lens.xyz/docs/protocol/usernames/fetch)

## SNS Notifications Setup
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# SNS Notifications

This guide will help you set up real-time push notification using Amazon SNS.

Lens utilizes [Amazon Simple Notification Service](https://aws.amazon.com/sns/) (SNS) to push notification events, enabling easy integration for third-party providers.
This service broadcasts data from the chain to your server based on the filters you apply when setting up the subscription.

## Before you get started

Before setting up any subscriptions, you will need to have a webhook endpoint deployed and publicly accessible.
This endpoint will be used to confirm the subscription and subsequently receive the notifications from Amazon SNS, so it should be able to handle POST requests and have a high uptime.
It is highly recommended to serve this endpoint over a secure HTTPS connection, but both HTTP and HTTPS are supported. Once you have this set up, you can proceed to the next step.

You can find examples below on how to create simple webhook using [Express.js](https://expressjs.com/) in TypeScript.

```
import bodyParser from "body-parser";import express from "express";import fetch from "node-fetch";
const app = express();const port = 8080;
app.use(bodyParser.urlencoded({ extended: false }));app.use(bodyParser.json());
app.post("/lens/notifications", async (req, res) => {  const buffers = [];
  for await (const chunk of req) {    buffers.push(chunk);  }
  const data = Buffer.concat(buffers).toString();  // example https://docs.aws.amazon.com/connect/latest/adminguide/sns-payload.html  const payload = JSON.parse(data);
  // if you already done the handshake you will get a Notification type  // example below: https://docs.aws.amazon.com/sns/latest/dg/sns-message-and-json-formats.html  // {  //   "Type" : "Notification",  //   "MessageId" : "22b80b92-fdea-4c2c-8f9d-bdfb0c7bf324",  //   "TopicArn" : "arn:aws:sns:us-west-2:123456789012:MyTopic",  //   "Subject" : "My First Message",  //   "Message" : "Hello world!",  //   "Timestamp" : "2012-05-02T00:54:06.655Z",  //   "SignatureVersion" : "1",  //   "Signature" : "EXAMPLEw6JRN…",  //   "SigningCertURL" : "https://sns.us-west-2.amazonaws.com/SimpleNotificationService-f3ecfb7224c7233fe7bb5f59f96de52f.pem",  //   "UnsubscribeURL" : "https://sns.us-west-2.amazonaws.com/?Action=Unsubscribe SubscriptionArn=arn:aws:sns:us-west-2:123456789012:MyTopic:c9135db0-26c4-47ec-8998-413945fb5a96"  // }  if (payload.Type === "Notification") {    console.log("SNS message is a notification ", payload);    console.log("------------------------------------------------------");    console.log("------------------------------------------------------");    console.log("------------------------------------------------------");    res.sendStatus(200);    return;  }
  // only need to do this the first time this is doing an handshake with the sns client  // example below: https://docs.aws.amazon.com/sns/latest/dg/sns-message-and-json-formats.html  // {  //   "Type" : "SubscriptionConfirmation",  //   "MessageId" : "165545c9-2a5c-472c-8df2-7ff2be2b3b1b",  //   "Token" : "2336412f37…",  //   "TopicArn" : "arn:aws:sns:us-west-2:123456789012:MyTopic",  //   "Message" : "You have chosen to subscribe to the topic arn:aws:sns:us-west-2:123456789012:MyTopic.\nTo confirm the subscription, visit the SubscribeURL included in this message.",  //   "SubscribeURL" : "https://sns.us-west-2.amazonaws.com/?Action=ConfirmSubscription&TopicArn=arn:aws:sns:us-west-2:123456789012:MyTopic&Token=2336412f37…",  //   "Timestamp" : "2012-04-26T20:45:04.751Z",  //   "SignatureVersion" : "1",  //   "Signature" : "EXAMPLEpH+DcEwjAPg8O9mY8dReBSwksfg2S7WKQcikcNKWLQjwu6A4VbeS0QHVCkhRS7fUQvi2egU3N858fiTDN6bkkOxYDVrY0Ad8L10Hs3zH81mtnPk5uvvolIC1CXGu43obcgFxeL3khZl8IKvO61GWB6jI9b5+gLPoBc1Q=",  //   "SigningCertURL" : "https://sns.us-west-2.amazonaws.com/SimpleNotificationService-f3ecfb7224c7233fe7bb5f59f96de52f.pem"  // }  if (payload.Type === "SubscriptionConfirmation") {    const url = payload.SubscribeURL;    const response = await fetch(url);    if (response.status === 200) {      console.log("Subscription confirmed");      console.log("------------------------------------------------------");      console.log("------------------------------------------------------");      console.log("------------------------------------------------------");      res.sendStatus(200);      return;    } else {      console.error("Subscription failed");      res.sendStatus(500);      return;    }  }
  console.log("Received message from SNS", payload);
  // if it gets this far it is a unsubscribe request  // {  //   "Type" : "UnsubscribeConfirmation",  //   "MessageId" : "47138184-6831-46b8-8f7c-afc488602d7d",  //   "Token" : "2336412f37…",  //   "TopicArn" : "arn:aws:sns:us-west-2:123456789012:MyTopic",  //   "Message" : "You have chosen to deactivate subscription arn:aws:sns:us-west-2:123456789012:MyTopic:2bcfbf39-05c3-41de-beaa-fcfcc21c8f55.\nTo cancel this operation and restore the subscription, visit the SubscribeURL included in this message.",  //   "SubscribeURL" : "https://sns.us-west-2.amazonaws.com/?Action=ConfirmSubscription&TopicArn=arn:aws:sns:us-west-2:123456789012:MyTopic&Token=2336412f37fb6…",  //   "Timestamp" : "2012-04-26T20:06:41.581Z",  //   "SignatureVersion" : "1",  //   "Signature" : "EXAMPLEHXgJm…",  //   "SigningCertURL" : "https://sns.us-west-2.amazonaws.com/SimpleNotificationService-f3ecfb7224c7233fe7bb5f59f96de52f.pem"  // }});
app.listen(port, () =>  console.log("SNS notification listening on port " + port + "!"));
```

The above are simple demonstrations, any production-ready webhook should include handling for incoming messages as well as errors.

## Subscribing to SNS Topics

Once you have the webhook endpoint deployed and accessible, you can now subscribe to Lens SNS notification topics via the Lens API.

The example below demonstrates how to create a subscription to the PostCreated and AccountCreated events using GraphQL.
For the mutation to succeed, you need to be authenticated on Lens with a Builder role.

You can notice that the postCreated topic has two optional fields: feed and app. These fields, if supplied in the request, will configure the SNS subscription
to filter the notifications to only those that are originating from a specific feed or app. There are more options available for filtering notifications,
which can be found in the reference further down in this article.

To highlight the contrast, the accountCreated topic does not have any optional filters which means you will receive notifications for all accounts created on Lens.

```
mutation CreateSnsSubscriptions {    createSnsSubscriptions(        request: {            # app: 0x0101010101010101010101010101010101010101, # Optionally link the subscription to an app            webhook: "https://example.com/webhook", # Replace with your own webhook endpoint            topics: [{              postCreated: {                feed: 0x0101010101010101010101010101010101010101,                app: 0x0101010101010101010101010101010101010101,              },              accountCreated: {}            ]        }    )}
```

A successful call to this mutation will return a list of subscriptions that were created as seen in the Response tab above. For each subscription, you will receive a POST request to the webhook URL you supplied, which will initiate a handshake with Amazon SNS to confirm the subscription.
An example of this message is shown above in SNS Confirmation Message, you need to visit the URL that was provided in the SubscribeURL field of the response and confirm the subscription.
From that point on, you will start receiving notifications for the topics you subscribed to.

## Filtering

Every subscription topic offers a number of filtering attributes which you can use to fine-grain the notifications you receive.
For example, you can filter the notifications to only those that are originating from a specific graph, app or a given account.
More details on the filtering attributes for each topic can be found in the reference further down in this article.

## Getting your SNS subscriptions

To get a list of your subscriptions, you can use the following query on the Lens API. First, authenticate with the builder role.
Then, perform the query and the endpoint will return a list of all subscriptions linked to your account.
You can optionally filter the subscriptions by the app they are linked to.

```
query GetSnsSubscriptions {  getSnsSubscriptions(request: {    app: "0x0101010101010101010101010101010101010101"  }) {    items {      id      account      webhook      topic      topicArn      attributes    } }}
```

## Deleting a Subscription

To delete a subscription, you can use the following mutation on the Lens API. First, authenticate with the builder role.
Then, perform the mutation and the endpoint will delete the subscription from your account.

```
mutation DeleteSnsSubscription {  deleteSnsSubscription(request: {    id: "d0a6e0c0-e6e3-4b8a-9293-14b58392e3e3"  })
```

## SNS Topics

Below is list of all the events fired by Lens, alongside their filtering attributes.
For every SNS topic, you will find a working example of how to create a subscription to it, as well as the
filtering attributes that can be applied on creation and the payload that will be sent to your webhook.

### Account

These are all the events that tract any Account-related activity.

#### AccountActionExecuted

Fires when an action is executed on an Account.

```
mutation CreateAccountActionExecutedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountActionExecuted: {          # Optional, filter events by account          # account: "0x0101010101010101010101010101010101010101",          # Optional, filter events by action          # action: "0x0101010101010101010101010101010101010101",          # Optional, filter events by action type enum          # actionType: "TIPPING" / "UNKNOWN"          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101",          # Optional, filter events by executing account          # executingAccount: "0x0101010101010101010101010101010101010101",        }      }]    }  )}
```

#### AccountCreated

Fires when a new Account is created.

```
mutation CreateAccountCreatedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountCreated: {          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101",          # Optional, filter events by graph          # graph: "0x0101010101010101010101010101010101010101",        }      }]    }  )}
```

#### AccountFollowed

Fires when an Account gets followed.

```
mutation CreateAccountFollowedNotification {  createSnsSubscriptions(    request: {       webhook: "https://example.com/webhook",       topics: [{          accountFollowed: {            # Optional, filter events by app            # app: "0x0101010101010101010101010101010101010101",            # Optional, filter events by graph            # graph: "0x0101010101010101010101010101010101010102",            # Optional, filter events by follower            # follower: "0x0101010101010101010101010101010101010103",            # Optional, filter events by followedAccount            # followedAccount: "0x0101010101010101010101010101010101010104",          }        }]      }    )  }
```

#### Account Unfollowed

Fires when an Account stops following another Account.

```
mutation CreateAccountUnfollowedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountUnfollowed: {          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101",          # Optional, filter events by graph          # graph: "0x0101010101010101010101010101010101010102",          # Optional, filter events by account unfollowing          # unfollower: "0x0101010101010101010101010101010101010103",          # Optional, filter events by unfollowed account          # unfollowedAccount: "0x0101010101010101010101010101010101010104"        }      }]    }  )}
```

#### AccountBlocked

Fires when an Account blocks another Account.

```
mutation CreateAccountBlockedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountBlocked: {          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101",          # Optional, filter events by graph          # graph: "0x0101010101010101010101010101010101010102",        }      }]    }  )}
```

#### AccountUnblocked

Fires when an Account unblocks another Account.

```
mutation CreateAccountUnblockedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountUnblocked: {          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101",          # Optional, filter events by graph          # graph: "0x0101010101010101010101010101010101010102",        }      }]    }  )}
```

#### AccountUsernameCreated

Fires when a username is created in a namespace.

```
mutation CreateAccountUsernameCreatedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountUsernameCreated: {          # Optional, filter events by namespace          # namespace: "0x0101010101010101010101010101010101010101",          # Optional, filter events by account          # account: "0x0101010101010101010101010101010101010101"        }      }]    }  )}
```

#### AccountUsernameAssigned

Fires when a username is assigned to an account.

```
mutation CreateAccountUsernameAssignedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountUsernameAssigned: {          # Optional, filter events by namespace          # namespace: "0x0101010101010101010101010101010101010101",          # Optional, filter events by account          # account: "0x0101010101010101010101010101010101010101"        }      }]    }  )}
```

#### AccountUsernameUnassigned

Fires when a username is unassigned from an account.

```
mutation CreateAccountUsernameUnassignedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountUsernameUnassigned: {          # Optional, filter events by namespace          # namespace: "0x0101010101010101010101010101010101010101",          # Optional, filter events by previous account          # previous_account: "0x0101010101010101010101010101010101010102"        }      }]    }  )}
```

#### AccountManagerAdded

Fires when an account is added as a manager to another account.

```
mutation CreateAccountManagerAddedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountManagerAdded: {          # Optional, filter events by managed account          # managed_account: "0x0101010101010101010101010101010101010101",          # Optional, filter events by manager address          # manager: "0x0101010101010101010101010101010101010101"        }      }]    }  )}
```

#### AccountManagerRemoved

Fires when an account is removed as a manager from another account.

```
mutation CreateAccountManagerRemovedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountManagerRemoved: {          # Optional, filter events by managed account          # managed_account: "0x0101010101010101010101010101010101010101",          # Optional, filter events by manager address          # manager: "0x0101010101010101010101010101010101010101"        }      }]    }  )}
```

#### AccountManagerUpdated

Fires when an account's manager permissions are updated.

```
mutation CreateAccountManagerUpdatedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountManagerUpdated: {          # Optional, filter events by managed account          # managed_account: "0x0101010101010101010101010101010101010101",          # Optional, filter events by manager address          # manager: "0x0101010101010101010101010101010101010101"        }      }]    }  )}
```

#### AccountOwnershipTransferred

This notification fires when ownership of an account is transferred to a new owner.

```
mutation CreateAccountOwnershipTransferredNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountOwnershipTransferred: {          # Optional, filter events by account          # account: "0x0101010101010101010101010101010101010101"        }      }]    }  )}
```

#### AccountReported

This notification fires when an account is reported by another user.

```
mutation CreateAccountReportedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountReported: {          # Optional, filter events by reported account          # reported_account: "0x0101010101010101010101010101010101010101",          # Optional, filter events by reporter          # reporter: "0x0101010101010101010101010101010101010101",          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101",        }      }]    }  )}
```

#### AccountMentioned

This notification fires when an account is mentioned in a post.

```
mutation CreateAccountMentionedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        accountMentioned: {          # Optional, filter events by author          # author: "0x0101010101010101010101010101010101010101",          # Optional, filter events by feed          # feed: "0x0101010101010101010101010101010101010101",          # Optional, filter events by mentioned account          # mentioned_account: "0x0101010101010101010101010101010101010101",          # Optional, filter events by mentioned username          # mentioned_username: "alice",          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101",        }      }]    }  )}
```

### Post

All the events related to posts.

#### PostActionExecuted

This notification fires every time a post action is executed.

```
mutation CreatePostActionExecutedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        postActionExecuted: {          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101",          # Optional, filter events by post id          # postId: "0101010101010101010101010101010101010101",          # Optional, filter events by action          # action: "0x0101010101010101010101010101010101010101",          # Optional, filter events by action type enum          # actionType: "TIPPING" / "SIMPLE_COLLECT" / "UNKNOWN"          # Optional, filter events by executing account          # executingAccount: "0x0101010101010101010101010101010101010101",          # Optional, filter events by receiving account          # receivingAccount: "0x0101010101010101010101010101010101010101",        }      }]    }  )}
```

#### PostCollected

This notification fires every time a post is collected.

```
mutation CreatePostCollectedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        postCollected: {          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101",          # Optional, filter events by collector          # collector: "0x0101010101010101010101010101010101010101",          # Optional, filter events by post author          # postAuthor: "0x0101010101010101010101010101010101010101",          # Optional, filter events by post id          # postId: "0101010101010101010101010101010101010101",        }      }]    }  )}
```

#### PostCreated

This notification fires every time a new Post gets indexed.

```
mutation CreatePostCreatedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        postCreated: {          # Optional, filter events by feed          # feed: "0x0101010101010101010101010101010101010101",          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101",          # Optional, filter events by parent post          # parent_post: "0x0101010101010101010101010101010101010101",          # Optional, filter events by post types          # postTypes: ["COMMENT"],          # Optional, filter events by author          # author: "0x0101010101010101010101010101010101010101"        }      }]    }  )}
```

#### PostEdited

This notification fires when a post is edited.

```
mutation CreatePostEditedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        postEdited: {          # Optional, filter events by feed          # feed: "0x0101010101010101010101010101010101010101",          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101",          # Optional, filter events by parent post          # parent_post: "0x0101010101010101010101010101010101010101",          # Optional, filter events by post types          # postTypes: ["COMMENT"],          # Optional, filter events by author          # author: "0x0101010101010101010101010101010101010101"        }      }]    }  )}
```

#### PostDeleted

This notification fires when a post is deleted.

```
mutation CreatePostDeletedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        postDeleted: {          # Optional, filter events by feed          # feed: "0x0101010101010101010101010101010101010101",          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101",          # Optional, filter events by parent post          # parent_post: "0x0101010101010101010101010101010101010101",          # Optional, filter events by post types          # postTypes: ["COMMENT"],          # Optional, filter events by author          # author: "0x0101010101010101010101010101010101010101"        }      }]    }  )}
```

#### PostReactionAdded

This notification fires when a reaction is added to a post.

```
mutation CreatePostReactionAddedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        postReactionAdded: {          # Optional, filter events by post id          # post_id: "0x0101010101010101010101010101010101010101",          # Optional, filter events by reacting account          # reacting_account: "0x0101010101010101010101010101010101010101",          # Optional, filter events by reaction type          # reaction_type: "UPVOTE",          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101"        }      }]    }  )}
```

#### PostReactionRemoved

This notification fires when a reaction is removed from a post.

```
mutation CreatePostReactionRemovedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        postReactionRemoved: {          # Optional, filter events by post id          # post_id: "0x0101010101010101010101010101010101010101",          # Optional, filter events by reacting account          # reacting_account: "0x0101010101010101010101010101010101010101",          # Optional, filter events by reaction type          # reaction_type: "UPVOTE",          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101"        }      }]    }  )}
```

#### PostReported

This notification fires when a post is reported.

```
mutation CreatePostReportedNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        postReported: {          # Optional, filter events by author          # author: "0x0101010101010101010101010101010101010101",          # Optional, filter events by reporter          # reporter: "0x0101010101010101010101010101010101010101",          # Optional, filter events by feed          # feed: "0x0101010101010101010101010101010101010101",          # Optional, filter events by app          # app: "0x0101010101010101010101010101010101010101"        }      }]    }  )}
```

### Metadata

All the events related to metadata snapshots, supports metadata snapshots of all Lens primitives.

#### MetadataSnapshotSuccess

This notification fires when a metadata snapshot is successfully created.

```
mutation CreateMetadataSnapshotSuccessNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        metadataSnapshotSuccess: {          # Optional, filter events by source          # source: "post_01",        }      }]    }  )}
```

#### MetadataSnapshotError

This notification fires when there's an error creating a metadata snapshot.

```
mutation CreateMetadataSnapshotErrorNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        metadataSnapshotError: {          # Optional, filter events by source          # source: "post_01",        }      }]    }  )}
```

### Media

All the events related to media snapshots, these include images, audio and video coming from Posts as well as metadata from all primitives.

#### MediaSnapshotSuccess

This notification fires when a media snapshot is successfully created.

```
mutation CreateMediaSnapshotSuccessNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        mediaSnapshotSuccess: {          # Optional, filter events by source          # source: "post_01020304",        }      }]    }  )}
```

#### MediaSnapshotError

This notification fires when there's an error creating a media snapshot.

```
mutation CreateMediaSnapshotErrorNotification {  createSnsSubscriptions(    request: {      webhook: "https://example.com/webhook",      topics: [{        mediaSnapshotError: {          # Optional, filter events by source          # source: "post_01020304",        }      }]    }  )}
```

[Previous\\
\\
**Data**](https://lens.xyz/docs/protocol/migration/from-polygon) [Next\\
\\
**BigQuery**](https://lens.xyz/docs/protocol/bigquery/introduction)

## Database Migration Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Database Migration

This guide will help you navigate schema changes and table updates from Lens v2 to v3.

The Lens V3 schema has been changed on reflection from all our learning on the past protocols.
If you were using Public Big Query this will show you want the names of the tables where and
what they are now. This guide will only highlight V2 tables any new ones you can look on
the Public Big Query. Note we have not integrated actions and rules yet in the API and indexer so they are missing from here for now.

## Key differences

- You will see on the schema a more less strict primary key and foreign key
structure, with Lens V3 we optimised for speed and indexing blockchain data
can be a lot faster if you process things concurrently.

- Database size has been optimised so we are storing binary format for all the hex values
which makes each value 2x less in size alongside makes queries faster.


## Moved Tables

Note the new tables may also have different columns.

- app\_stats.profile \> app.account\_post\_summary

- app\_stats.profile\_reacted \> app.account\_reacted\_summary

- app\_stats.profile\_reaction \> app.account\_reaction\_summary

- app\_stats.publication \> app.post\_summary

- app\_stats.publication\_reaction \> app.post\_reaction\_summary

- app\_stats.publication\_tag \> app.post\_tag\_summary

- curation.profile \> curation.account

- curation.profile\_tag \> curation.account\_tag

- enabled.currency \> currencies.record

- global\_stats.profile \> account.post\_summary

- global\_stats.profile\_follower \> account.follower\_summary

- global\_stats.profile\_reacted \> account.reacted\_summary

- global\_stats.profile\_reaction \> account.reaction\_summary

- global\_stats.publication \> post.summary

- global\_stats.publication\_reaction \> post.reaction\_summary

- global\_stats.publication\_tag \> post.tag\_summary

- machine\_learning.for\_you\_global\_feed \> ml.for\_you\_global\_timeline

- machine\_learning.popularity\_trending\_feed \> ml.popularity\_trending\_timeline

- machine\_learning.profile\_boosting \> ml.account\_boosting

- machine\_learning.quality\_profiles \> ml.account\_score

- machine\_learning.reply\_ranking \> ml.reply\_ranking

- namespace.handle \> username.record

- namespace.record \> username.namespace\_record

- namespace.handle\_link \> account.username\_assigned

- notification.record \> account.notification

- personalisation.bookmarked\_publication \> account.bookmarked\_post

- personalisation.not\_interested\_publication \> account.not\_interested\_post

- personalisation.wtf\_recommendation\_dismissed \> ml.who\_to\_follow\_dismissed

- personalisation.wtf\_recommendation\_dismissed \> ml.who\_to\_follow\_dismissed

- profile.follow\_module \> account.follow\_rule

- profile.last\_logged\_in \> account.last\_logged\_in

- profile.follower \> account.follower

- profile.ownership\_history \> account.record\_owner\_history

- profile.peer\_to\_peer\_recommendation \> account.peer\_to\_peer\_recommendation

- publication.mention \> post.mention

- profile.record \> account.record

- profile.reported \> account.reported

- publication.hashtag \> post.hashtag

- publication.open\_action\_module \> post.action

- publication.open\_action\_module\_acted\_record \> account.acted

- publication.metadata \> post.metadata

- publication.open\_action\_module\_collect\_nft \> post.action column collect\_nft\_address

- publication.open\_action\_module\_multirecipient \> post.action column recipients

- publication.reaction \> post.reaction

- publication.reaction\_type \> post.reaction\_type

- publication.record \> post.record

- publication.reported \> post.reported

- publication.tag \> post.tag

- profile.blocked \> account.blocked

- profile.manager \> account.manager

- profile.metadata \> account.metadata

- profile.metadata\_failed \> metadata.failed

- profile.metadata\_pending \> metadata.pending

- publication.failed \> metadata.failed

- publication.pending \> metadata.pending

- publication.type \> post.type

- enabled.follow\_module \> Not completed yet

- enable.reference\_module \> Not completed yet

- enabled.open\_action\_module\> Not completed yet

- profile.follow\_module\_record \> Not completed yet

- publication.reference\_module \> Not completed yet

- publication.referrer \> Not completed yet

- publication.open\_action\_module\_acted\_record\_referrer \> Not completed yet


## Deprecated Tables

These tables have been killed

- app.onboarding\_access

- app.onboarding\_handle

- app.onboarding\_profile

- app.profile\_revenue

- app.profile\_revenue

- app.profile\_revenue\_record

- app.public\_key

- app.publication\_revenue

- app.publication\_revenue\_open\_action

- app.publication\_revenue\_record

- app\_stats.hashtag

- app\_stats.mention

- app\_stats.mention\_handle

- app\_stats.profile\_open\_action

- app\_stats.publication\_content\_warning

- app\_stats.publication\_locale

- app\_stats.publication\_main\_content\_focus

- app\_stats.publication\_open\_action

- app\_stats.publication\_tagged

- curation.profile\_interest

- enabled.currency\_history

- enabled.follow\_module\_history

- enabled.open\_action\_module\_history

- enable.profile\_creator

- enable.profile\_creator\_history

- enable.reference\_module\_history

- ens

- fiat

- global\_stats.hashtag

- global\_stats.mention

- global\_stats.mention\_handle

- global\_stats.profile\_manager

- global\_stats.profile\_open\_action

- global\_stats.publication\_content\_warning

- global\_stats.publication\_locale

- global\_stats.publication\_main\_content\_focus

- global\_stats.publication\_open\_action

- global\_stats.publication\_tagged

- machine\_learning.profile\_boosting\_history

- machine\_learning.proof\_of\_human

- media.livepeer\_mapping

- momoka.\*

- namespace.handle\_guardian

- namespace.handle\_guardian\_history

- namespace.handle\_history

- namespace.handle\_link\_history

- nft.\*

- notification.type

- personalisation.bookmarked\_publication\_history

- personalisation.not\_interested\_publication\_history

- poap.\*

- profile.action\_history

- profile.blocked\_history

- profile.default

- profile.follow\_module\_history

- profile.follow\_nft

- profile.follower\_history

- profile.gallery

- profile.gallery\_history

- profile.guardian

- profile.guardian\_history

- profile.interest

- profile.interest\_history

- profile.manager\_active\_config\_number

- profile.manager\_active\_config\_number\_history

- profile.manager\_all\_config

- profile.manager\_all\_config\_history

- profile.metadata\_history

- profile.nft\_picture

- profile.nft\_picture\_history

- profile.revenue

- profile.revenue\_record

- profile.unfollow\_audit\_log

- proof\_of\_humanity.\*

- protocol.\*

- publication.hashtag\_history

- publication.id

- publication.mention\_history

- publication.metadata\_history

- publication.open\_action\_module\_collect\_nft\_ownership

- publication.open\_action\_module\_collect\_nft\_ownership\_history

- publication.open\_action\_module\_history

- publication.reaction\_history

- publication.reference\_module\_history

- publication.revenue

- publication.revenue\_open\_action

- publication.revenue\_record

- publication.secured\_metadata\_id\_executed

- publication.tag\_history

- sybil\_dot\_org.\*

- worldcoin.\*


[Previous\\
\\
**API**](https://lens.xyz/docs/protocol/migration/api) [Next\\
\\
**Data**](https://lens.xyz/docs/protocol/migration/from-polygon)

## Lens Migration Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Migration Plan From Lens V2

This guide will walk you through how data will be migrated from Lens v2 on Polygon to Lens v3.

Lens V2 is currently live on Polygon and we will be migrating all the data for Lens V3 onto Lens Chain.
We want to apply the migration on the initial creation of Lens Chain mainnet and in turn make it automatic and seemless
as possible for everyone. Below we walk through all the data we will migrate and how we are going to approach it please
note that these migration plans are still work in progress and can change as we get feedback from people.

## Profiles > Accounts

Lens V2 Profiles which are now called accounts on Lens V3 will be migrated automatically, the big difference between Profiles and Accounts
is that Profiles are an NFT and accounts on Lens V3 are a smart wallet. The flow of the migration will be this:

1

### The Profile is owned by an EOA

If the Profile is owned by an EOA then we will deploy a new Account and give ownership to that EOA.

2

### The Profile is owned by a Safe

If the Safe has a 1/1 signer and that signer is EOA we will deploy a new Safe and assign the same 1/1 signer up,
we will then deploy a new Account and give ownership to that Account to the Safe.

3

### The Profile is owned by an unknown Contract

If this is the case we will mint the Account on your behalf and have way via the Lens API you can claim it by signing
if possible, if not possible we can work with you to prove ownership then change ownership of the Account over to you.

## Handles > Usernames

Lens V2 Handles which are now called Usernames on Lens V3 will be migrated automatically.
We will follow a similar process for how we will go about migrating Profiles onto Lens V3.
Usernames can have many namespaces so all of the below will happen on the lens namespace.

1

### The Handle is owned by an EOA

If the Handle is owned by an EOA then we will deploy a new Account and give ownership to that EOA.
If that EOA has deployed an Account we will send the username to the Account smart wallet.

2

### The Handle is owned by a Safe

If the Safe has a 1/1 signer and that signer is EOA we will deploy a new Safe and assign the same 1/1 signer up,
we will then mint the username and give ownership to that username to the Safe. If the Safe has already been deployed
when migrating the Account we will send the username to the Account smart wallet.

3

### The Handle is owned by an unknown Contract

If this is the case we will mint the Username on your behalf and have way via the Lens API you can claim it by signing
if possible, if not possible we can work with you to prove ownership then send the Username over to you.

## Profiles Linked To Handles > Username Linked To Accounts

On Lens V2 Profiles were also linked to Handles we will automatically apply this link if exists.

## Profile Managers > Account Managers

On Lens V2 we had Profile managers which could do stuff onbehalf of the Profile, in Lens V3 we have Account Managers
which can control aspects on the Account. We also have Lens API Profile managers who enabled signless for the user.

1

### The Profile manager is owned by Lens API

In this case we will generate a new Lens API dispatcher so you can still do signless on Lens V3. With Lens V3
dispatchers are now 1 of 1 this means each dispatcher is not shared with anyone else but you.

2

### The Profile manager is an EOA

We will assign this EOA as Account manager

3

### The Profile manager is a Contract or Safe

If the current Profile manager is a contract or a safe we will not assign it and will need to be added again.

## Blocked Profiles > Blocked Accounts

Any Profiles you blocked on Lens V2 will be applied to Lens V3.

## Follow connections

On Lens V3 we now have multiple graphs so we will migrate all the follows on Lens V2 and apply them on the global graph automatically.

## Profile Follow Modules > Follow Rules

On Lens V2 you could set paid to follow if that is the case we will enable that follow rule on your account but it will be applied as
GHO and be the exchange rate at the time of migration.

## Publications > Posts

On Lens V3 we now have multiple feeds so we will migrate all the publications to posts on the global feed.

## Post/Account Metadata Storage

We will honour the metadata it is stored on and advise people to look at the storage nodes for future uploads.

## Publication Actions > Post Actions

We will not auto set any Post Actions for the Account, the Lens V3 supports editing Posts so if you want to enable
that action on Lens V3 you can edit and set it up. This includes collect actions.

## Collects

Collects are NFTs which live on within the network itself in this case Polygon so we will not be deploying any collections
from Lens V2.

## Centralised Data

All centralised data like reactions, reports, recommendations will be migrated.

## ML trainned algos

All machine learning modals will be migrated and supported on Lens V3.

## Future of Lens V2

After the launch of Lens Chain and the migration of Lens V2 data onto Lens V3 we will slowly start deprecating Lens V2 protocol
infrastructure support for the protocol which we run including The Lens API. Below is a list of actions we will do, timelines of us
deprecating this is open, we want to support the apps migrating over and one of the main reasons we have done a dev preview first.

### Gas Sponsorship

As the Lens API pays for most the gas costs for the users on behalf of the apps we firstly will bring this limit down slowly to 0.
This includes Momoka publications which we will slowly also bring down the amount of limits people can post using it. The slow down
of the gas paying will start instantly on mainnet launch.

### Lens API and Indexers

The Lens API and indexers powers most of the applications built in Lens in some way, on launch of Lens Chain we will decrease the server sizes for the
API which in turn will mean it will be slower then it is now for queries. Over time we will completely turn this off.

### Public Big Query

The Lens indexers publishes all the indexed data to public big query to allow anyone to query it. This will be supported until we turn off the Lens API
and indexers.

### SNS

SNS powers some apps by doing push notifications when events are indexed. This will be supported until we turn off the Lens API
and indexers.

### Direct DB access

If you have a read replica of the Lens DB this will also be scaled down on launch of Lens Chain and revoked access after a short period of time.
We can work with the apps to work out the timescale which makes sense for them.

### General Bug Fixing / Support

On launch of the mainnet for Lens Chain with Lens V3 we will not maintain or support bugs and give developer support on the old protocol,
we will also not add any new features. The only way we will react is if the bug is a critical and users funds/identities are at risk.

[Previous\\
\\
**Database**](https://lens.xyz/docs/protocol/migration/database) [Next\\
\\
**Tools**](https://lens.xyz/docs/protocol/tools/sns-notifications)

## Lens Protocol Rules
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Page not found.

Sorry. The page you're looking for can't be found.

Back to home

## Banned Accounts Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Banned Accounts

This guide explain how to ban and unban accounts from a group.

A Group configured with the [Ban Member Group Rule](https://lens.xyz/docs/protocol/groups/rules#using-group-rules-ban-member-group-rule) allows the Group owner or admins to ban accounts from joining the Group. However, banning an account after it has already joined the Group does not remove it.

More details on how to remove a Group member and ban them contextually will be
provided soon.

## Ban Accounts

To ban one or mores accounts from joining a Group, follow these steps.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication), [Account\\
Manager](https://lens.xyz/docs/protocol/authentication), or [Account Owner](https://lens.xyz/docs/protocol/authentication) and be the
Group owner or an admin to perform this action.

1

### Ban the Accounts

- TypeScript
- GraphQL
- React

Use the banGroupAccounts action to ban one or more accounts from joining a given Group.

```
import { evmAddress } from "@lens-protocol/client";import { banGroupAccounts } from "@lens-protocol/client/actions";
const result = await banGroupAccounts(sessionClient, {  group: evmAddress("0xe2f…"),  accounts: [evmAddress("0x4f91…"), evmAddress("0x4f92…")],});
if (result.isErr()) {  return console.error(result.error);}
```

2

### Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await banGroupAccounts(sessionClient, {  group: evmAddress("0xe2f…"),  accounts: [evmAddress("0x4f91…"), evmAddress("0x4f92…")],}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

That's it—these accounts are now banned from joining the Group.

## List Banned Accounts

- TypeScript
- GraphQL
- React

Use the paginated fetchGroupBannedAccounts action to list all banned accounts for a given Group.

```
import { evmAddress } from "@lens-protocol/client";import { fetchGroupBannedAccounts } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await fetchGroupBannedAccounts(client, {  group: evmAddress("0x1234…"),});
if (result.isErr()) {  return console.error(result.error);}
// items: Array<GroupBannedAccount>: [{ account: Account, bannedAt: DateTime, bannedBy: Account, …}, …]const { items, pageInfo } = result.value;
```

See the [Pagination](https://lens.xyz/docs/protocol/best-practices/pagination) guide for more information on how to handle paginated results.

## Unban Accounts

To revert bans and allow accounts to join a Group again, follow these steps.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication), [Account\\
Manager](https://lens.xyz/docs/protocol/authentication), or [Account Owner](https://lens.xyz/docs/protocol/authentication) and be the
Group owner or an admin to perform this action.

1

### Unban the Accounts

- TypeScript
- GraphQL
- React

Use the unbanGroupAccounts action to unban one or more accounts for a given Group.

```
import { evmAddress } from "@lens-protocol/client";import { unbanGroupAccounts } from "@lens-protocol/client/actions";
const result = await unbanGroupAccounts(sessionClient, {  group: evmAddress("0xe2f…"),  accounts: [evmAddress("0x4f91…"), evmAddress("0x4f92…")],});
if (result.isErr()) {  return console.error(result.error);}
```

2

### Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await unbanGroupAccounts(sessionClient, {  group: evmAddress("0xe2f…"),  accounts: [evmAddress("0x4f91…"), evmAddress("0x4f92…")],}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

That's it—these accounts are now banned from joining the Group.

[Previous\\
\\
**Groups Rules**](https://lens.xyz/docs/protocol/groups/rules) [Next\\
\\
**Membership Approvals**](https://lens.xyz/docs/protocol/groups/membership-approvals)

## Mute Accounts Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Mute Accounts

This guide will show you how to mute accounts in Lens API.

The Lens API allows you to mute an account, so you won’t receive notifications from the muted account’s activities.

This feature only affects the data returned to the account performing the
mute; the muted account will still be able to interact with its content. To
prevent an account from interacting with your content entirely, see [Block\\
Accounts](https://lens.xyz/docs/protocol/accounts/block).

You MUST be authenticated as Account Owner or Account Manager to make this
request.

- TypeScript
- GraphQL
- React

Use the mute action to mute an account. To unmute the account, use the unmute action.

```
import { evmAddress } from "@lens-protocol/client";import { muteAccount } from "@lens-protocol/client/actions";

const result = await muteAccount(sessionClient, {  account: evmAddress("01234…"),});
if (result.isErr()) {  return console.error(result.error);}
```

That's it—the account is now muted.

[Previous\\
\\
**Account Managers**](https://lens.xyz/docs/protocol/accounts/manager) [Next\\
\\
**Block Accounts**](https://lens.xyz/docs/protocol/accounts/block)

## Post Actions Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Post Actions

This guide will explain how to use Post Actions and how to implement custom ones.

Post Actions are contracts that extend the Lens Protocol functionality by allowing Accounts to execute actions on Posts.

Lens provides two built-in Post Actions:

- SimpleCollectAction \- Allows an Account to collect an NFT from a Post.

- TippingPostAction \- Allows an Account to tip the author of a Post.


It is also possible to create custom Post Actions to extend the functionality of the Lens Protocol.

## Configuring Post Actions

You can configure one or more Post Actions when creating a Post.

This section presumes you are familiar with the process of [creating a\\
Post](https://lens.xyz/docs/protocol/feeds/post) on Lens.

### Simple Collect Action

The SimpleCollectAction allows an user to collect an [ERC-721](https://ethereum.org/en/developers/docs/standards/tokens/erc-721/) NFT from a given Post.

The NFT collection is _eagerly deployed_ when the Post is created.

The Post author can configure the following parameters:

- **Collect limit** (optional) – The maximum number of NFTs that can be minted.

- **End time** (optional) – The deadline after which NFTs can no longer be collected.

- **Follower requirement** (optional) – Whether the collector must be following the Post author on a specified Lens Graph (global or custom).

- **NFT immutability** (optional) – If enabled, minted NFTs will retain a snapshot of the content URI at the time of minting. This ensures that any edits to the Post after minting will not affect previously minted NFTs. For this to be fully effective, the content URI itself should be immutable.

- **Price** (optional) – The cost of the NFT. If set, the author can also specify:


- **Referral share** (optional) – The percentage of the payment allocated to any referrers.

- **Recipients** – A list of addresses that will receive a share of the payment. This is after the referral share has been deducted.


For paid collects, a **1.5%** Lens treasury fee is deducted from the total
amount paid by the collector before calculating referral and recipient shares.

- TypeScript
- GraphQL

```
import { dateTime, evmAddress, uri } from "@lens-protocol/client";
const result = await post(sessionClient, {  contentUri: uri("lens://4f91ca…"),  actions: [    {      simpleCollect: {        collectLimit: 100,        endsAt: dateTime("2032-12-22T00:00:00Z"),      },    },  ],});
```

### Tipping Post Action

Lens includes a built-in TippingPostAction, which is enabled by default and allows an Account to tip the author of a Post using any ERC20 token. Work is underway to add support for native GHO tipping (GRASS on the Lens Testnet).

The TippingPostAction supports a referral scheme that lets you reward accounts or apps that helped surface the tipped Post.

A maximum of **20%** of the tipped amount can be allocated to referrals, but only if they're explicitly included when the tip is sent.

A **1.5%** Lens treasury fee is deducted from the total amount paid by the
tipper before calculating referral and recipient shares.

### Referral Fee Breakdown

Let’s say a user tips the author of a Post with **100 GHO** using the TippingPostAction.

Here's how the amount is split:

- **1.5 GHO** (1.5%) is deducted for the **Lens treasury fee**

- **98.5 GHO** remains


The user includes two referral recipients, fully allocating the maximum **20% referral fee** between them:

- 0xc0ffee with a **30% share** of the referral portion

- 0xbeef with a **70% share** of the referral portion


From the **98.5 GHO**:

- **19.7 GHO** (20%) is distributed as referrals:


- **5.91 GHO** to 0xc0ffee

- **13.79 GHO** to 0xbeef


- **78.8 GHO** is sent to the **Post author**


If the referral split adds up to less than 100% (e.g. a single referral with
50%), only the corresponding portion of the 20% referral fee will be used. The
unused remainder goes to the Post author.

### Custom Post Actions

- TypeScript
- GraphQL

```
import { blockchainData, evmAddress, uri } from "@lens-protocol/client";
const result = await post(sessionClient, {  contentUri: uri("lens://4f91ca…"),  actions: [    {      unknown: {        address: evmAddress("0x1234…"),        params: [          {            raw: {              // 32 bytes key (e.g., keccak(name))              key: blockchainData("0xac5f04…"),              // an ABI encoded value              value: blockchainData("0x00"),            },          },        ],      },    },  ],});
```

## Executing Post Actions

To execute a Post Action, follow these steps.

You MUST be authenticated as Account Owner or Account Manager to execute a
Post Action.

1

### Inspect Post Actions

First, inspect the post.actions field to determine what Post Actions are available on a given Post.

```
for (const action of post.actions) {  switch (action.__typename) {    case "SimpleCollectAction":      // The Post has a Simple Collect Action      break;
    case "UnknownAction":      // The Post has a Custom Post Action      break;  }}
```

An example of each Post Action type is provided below.

```
{  "__typename": "SimpleCollectAction",  "payToCollect": {    "__typename": "PayToCollectConfig",    "amount": {      "__typename": "Erc20Amount",      "asset": {        "__typename": "Erc20",        "name": "Wrapped GHO",        "symbol": "wGHO",        "contract": {          "__typename": "NetworkAddress",          "address": "0x1234…",          "chainId": 37111        },        "decimals": 18      },      "value": "42.42"    },    "referralShare": 5, // 5%    "recipients": [      {        "__typename": "RecipientPercent",        "address": "0x5678…",        "percent": 30 // 30%      },      {        "__typename": "RecipientPercent",        "address": "0x9abc…",        "percent": 70 // 70%      }    ]  },  "collectLimit": 100,  "endsAt": "2032-12-22T00:00:00Z",  "followerOnGraph": {    "__typename": "FollowerOn",    "globalGraph": true  },  "isImmutable": true}
```

2

### Execute Post Action

Next, execute the desired Post Action.

- TypeScript
- GraphQL
- React

Use the executePostAction action to execute any Post Action.

```
import { postId } from "@lens-protocol/client";import { executePostAction } from "@lens-protocol/client/actions";
const result = await executePostAction(sessionClient, {  post: postId("42"),  action: {    simpleCollect: {      selected: true,    },  },});
if (result.isErr()) {  return console.error(result.error);}
```

3

### Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await executePostAction(sessionClient, {  post: postId("42"),  action: {    // …  },}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

That's it—you've successfully executed a Post Action.

## Action Execution History

The Lens Protocol provides a method to track which accounts have executed specific actions on a Post.

- TypeScript
- GraphQL
- React

Use the paginated fetchWhoExecutedActionOnPost action to get a list of accounts that executed a specific Action on a Post.

```
import { postId } from "@lens-protocol/client";import { fetchWhoExecutedActionOnPost } from "@lens-protocol/client/queries";
const result = await fetchWhoExecutedActionOnPost(client, {  post: postId("42"),});
if (result.isErr()) {  return console.error(result.error);}
// items: Array<PostExecutedActions>const { items, pageInfo } = result.value;
```

## Enable/Disable Post Actions

To enable/disable a Post Action, follow these steps.

You MUST be authenticated as the Account Owner or Account Manager of the
Post's author account to enable or disable Post Actions.

1

### Enable/Disable Owned Post Action

- TypeScript
- GraphQL

First, enable or disable a specific Post Action invoking the corresponding enablePostAction or disablePostAction actions.

```
import { postId } from "@lens-protocol/client";import { enablePostAction } from "@lens-protocol/client/actions";
const result = await enablePostAction(sessionClient, {  post: postId("1234…"),  action: { simpleCollect: true },});
```

2

### Handle Result

- TypeScript
- GraphQL

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await enablePostAction(sessionClient, {  post: postId("1234…"),  action: { simpleCollect: true },}).andThen(handleOperationWith(walletClient));
```

The Lens SDK example here leverages a functional approach to chaining
operations using the Result<T, E> object. See the [Error\\
Handling](https://lens.xyz/docs/protocol/best-practices/error-handling) guide for more
information.

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Building a Post Action

The Post Actions are defined by the IPostAction interface, which basically requires three functions, one to configure the action, one to execute it, and another to disable it.

```
interface IPostAction {    function configure(address originalMsgSender, address feed, uint256 postId, KeyValue[] calldata params)        external        returns (bytes memory);
    function execute(address originalMsgSender, address feed, uint256 postId, KeyValue[] calldata params)        external        returns (bytes memory);
    function setDisabled(        address originalMsgSender,        address feed,        uint256 postId,        bool isDisabled,        KeyValue[] calldata params    ) external returns (bytes memory);}
```

### But first, let's talk about the ActionHub

Before we dive into each of the functions from the IPostAction interface, we need to talk about the ActionHub.

The ActionHub is a special contract that acts as the entry point for every Action in the Lens Protocol.

The purpose of that is to help discovery of Actions, having a single point where all main Action-related events are emitted.

So, each function of the IPostAction interface must be only callable by ActionHub. For this, you can inherit [BasePostAction contract](https://github.com/lens-protocol/lens-v3/blob/development/contracts/actions/post/base/BasePostAction.sol), which acts as template for your custom Post Action, applying the restrictions needed, so you do not need to worry about it.

With this context, you can now understand why the first param of every IPostAction function is originalMsgSender: this is the address that called the ActionHub originally, either to configure, execute, or disable an Action, given that msg.sender will always have the ActionHub address in the context of your Action contract.

### Configuration

The configuration of the Action is done through the configure function, which purpose is to initialize any required state that the Action might require to work properly.

The function receives four parameters:

- originalMsgSender: the address of the original msg.sender that invoked the ActionHub (as explained above).

- feed: the address of the Feed where the Post the Action is being configured for belongs to.

- postId: the ID of the Post for which the Action is configured for.

- params: array of key-value pairs whose values can be decoded into any extra custom configuration parameters that the Action could require to work.


Return of the configure function is bytes - some Actions might want to return custom information to the caller.

This configure function could be called by anyone (through the ActionHub, as explained above), it will depend on the implementation of the Action and its purpose who is allowed to invoke it (based on originalMsgSender).

For example, there might be Actions that do not require initialization at all, so the configure function implementation will be empty, while other Actions might require the caller to match the author of the given Post.

Keep in mind that if no prior configuration is required, the configure
function must still be implemented and must not revert.

Every time the configure function is called, the ActionHub will emit a Lens\_ActionHub\_PostAction\_Configured event matching the parameters of the call (or Lens\_ActionHub\_PostAction\_Reconfigured if the configuration was updated).

### Execution

The execution of the Action is done through the execute function, which purpose is to perform the actual action logic that the Action implements.

The function receives four parameters:

- originalMsgSender: the address of the original msg.sender that invoked the ActionHub (as explained above).

- feed: the address of the Feed where the Post the Action is being executed for belongs to.

- postId: the ID of the Post for which the Action is being executed.

- params: array of key-value pairs whose values can be decoded into any extra custom execution parameters that the Action could require to work.


Return of the execute function is bytes - some Actions might want to return custom information to the caller.

This execute function could be called by anyone (through the ActionHub, as explained above), it will depend on the implementation of the Action and its purpose who is allowed to invoke it (based on originalMsgSender).

For example, there might be Actions that do not require any permissions at all, so the execute function implementation will be open, while other Actions might require the caller to match the author of the given Post.

Every time the execute function is called, the ActionHub will emit a Lens\_ActionHub\_PostAction\_Executed event matching the parameters of the call.

The ActionHub will not allow to invoke the execute function on a Post if the
Action is disabled for it.

### Disabling

The disabling of the Action is done through the setDisabled function, which purpose is to stop an Action to be executable for a given Post. The same function can be used to enable the Action back.

The function receives five parameters:

- originalMsgSender: the address of the original msg.sender that invoked the ActionHub (as explained above).

- feed: the address of the Feed where the Post the Action is being disabled/enabled for belongs to.

- postId: the ID of the Post for which the Action is being disabled/enabled.

- isDisabled: boolean indicating if the Action is being disabled or enabled.

- params: array of key-value pairs whose values can be decoded into any extra custom disabling/enabling parameters that the Action could require to work.


Return of the setDisabled function is bytes - some Actions might want to return custom information to the caller.

This setDisabled function could be called by anyone (through the ActionHub, as explained above), it will depend on the implementation of the Action and its purpose who is allowed to invoke it (based on originalMsgSender).

Every time the setDisabled function is called, the ActionHub will emit a Lens\_ActionHub\_PostAction\_Disabled event matching the parameters of the call.

### Example

Let's illustrate the process with an example. We will build a Simple Poll Vote Action so users can vote (e.g., Yes/No) on a Post representing a poll. This action allows any user to vote once per post.

1

#### Define the Event and State

First, we define an event PollVoted to signal when a vote occurs and a mapping \_hasVoted to track addresses that have already voted on a specific post to prevent double voting.

```
// SPDX-License-Identifier: MITpragma solidity ^0.8.20;
import { IPostAction } from "contracts/interfaces/IPostAction.sol";import { KeyValue } from "contracts/core/types/Types.sol";import { BasePostAction } from "contracts/actions/post/base/BasePostAction.sol";
contract SimplePollVoteAction is BasePostAction {    event PollVoted(address indexed voter, uint256 indexed postId, bool vote);
    mapping(address feed => mapping(uint256 postId => mapping(address voter => bool hasVoted))) private _hasVoted;
    mapping(address feed => mapping(uint256 postId => mapping(bool vote => uint256 count))) private _voteCounts;
```

2

#### Implement the Configure Function

Next, implement the configure function. Although this simple poll action doesn't store complex configuration state on-chain (like the specific poll question), it's crucial for the **post author** to explicitly enable or "attach" this action to their post. This signals intent and allows UIs to discover that the post is intended as a poll.

We add a requirement that originalMsgSender (the address calling the ActionHub) must be the author of the postId on the given feed.

```
// ... inside SimplePollVoteAction ...
    function _configure(        address originalMsgSender,        address feed,        uint256 postId,        KeyValue[] calldata params    ) internal override returns (bytes memory) {        require(            originalMsgSender == IFeed(feed).getPostAuthor(postId),            "Only author can configure"        );        // Any extra configuration logic could be added here (e.g. mapping each possible vote type to some string)        // Emitting an event Lens_ActionHub_PostAction_Configured happens automatically via ActionHub        return "";    }
```

3

#### Implement the Execute Function

Implement the execute function. This is where the core voting logic resides.

First, we check if the originalMsgSender (the user initiating the action via the ActionHub) has already voted on this postId. If they have, the transaction reverts.

```
// ... inside SimplePollVoteAction ...
    function _execute(        address originalMsgSender,        address feed,        uint256 postId,        KeyValue[] calldata params    ) external override returns (bytes memory) {        require(!_hasVoted[feed][postId][originalMsgSender], "Already voted");
        _hasVoted[feed][postId][originalMsgSender] = true;
        bool voteFound;        bool vote;        for (uint256 i = 0; i < params.length; i++) {          if (params[i].key == keccak256("lens.param.vote")) {              voteFound = true;              vote = abi.decode(params[i].value, (bool));              break;          }        }
        require(voteFound, "Vote not found in params");
        _voteCounts[feed][postId][vote]++;
        return abi.encode(vote);    }
```

We can also add some getters for vote counts and then the SimplePollVoteAction is ready to be deployed and used.

See the full code below:

```
// SPDX-License-Identifier: MITpragma solidity ^0.8.20;
import { IPostAction } from "contracts/extensions/action/ActionHub.sol";import { KeyValue } from "contracts/core/types/Types.sol";import { BasePostAction } from "contracts/actions/post/base/BasePostAction.sol";import { IFeed } from "contracts/interfaces/IFeed.sol";
/** * @title SimplePollVoteAction * @notice A simple post action allowing users to cast a boolean vote (e.g., Yes/No) on a post. *         Prevents double voting. */contract SimplePollVoteAction is BasePostAction {    event PollVoted(address indexed voter, uint256 indexed postId, bool vote);
    // feed => postId => voter => hasVoted    mapping(address => mapping(uint256 => mapping(address => bool))) private _hasVoted;
    /**      * @notice Configures the SimplePollVote Action for a given post.      * @param originalMsgSender The address initiating the configuration via the ActionHub. Must be post author.      * @param feed The address of the feed contract where the post exists.      * @param postId The ID of the post being configured.      * @param params Not used      * @return bytes Empty bytes.     */    function _configure(        address originalMsgSender,        address feed,        uint256 postId,        KeyValue[] calldata params    ) internal override returns (bytes memory) {        require(            originalMsgSender == IFeed(feed).getPostAuthor(postId),            "Only author can configure"        );        // Any extra configuration logic could be added here (e.g. mapping each possible vote type to some string)        // Emitting an event Lens_ActionHub_PostAction_Configured happens automatically via ActionHub        return "";    }
    /**     * @notice Executes a vote on a given post.     * @param originalMsgSender The address initiating the vote via the ActionHub.     * @param feed The address of the feed contract where the post exists.     * @param postId The ID of the post being voted on.     * @param params Array of key-value pairs. Expected to contain at least one element,     *        where the `value` of the first element is the ABI-encoded boolean vote.     * @return bytes Empty bytes.     * Requirements:     * - The `originalMsgSender` must not have voted on this `postId` before.     * - `params` must not be empty and the first element's value must be abi-decodable as a boolean.     */    function _execute(        address originalMsgSender,        address feed,        uint256 postId,        KeyValue[] calldata params    ) external override returns (bytes memory) {        require(!_hasVoted[feed][postId][originalMsgSender], "Already voted");
        _hasVoted[feed][postId][originalMsgSender] = true;
        bool voteFound;        bool vote;        for (uint256 i = 0; i < params.length; i++) {          if (params[i].key == keccak256("lens.param.vote")) {              voteFound = true;              vote = abi.decode(params[i].value, (bool));              break;          }        }
        require(voteFound, "Vote not found in params");
        _voteCounts[feed][postId][vote]++;
        return abi.encode(vote);    }
    /**     * @notice Gets the vote counts for a specific post.     * @param feed The address of the feed contract where the post exists.     * @param postId The ID of the post to get vote counts for.     * @return (uint256, uint256) A tuple containing the counts for false and true votes respectively.     */    function getVoteCounts(address feed, uint256 postId) external view returns (uint256 ya, uint256 nay) {        return (_voteCounts[feed][postId][false], _voteCounts[feed][postId][true]);    }}
```

[Previous\\
\\
**Boost Engagement**](https://lens.xyz/docs/protocol/feeds/boost-engagement) [Next\\
\\
**Provide Feedback**](https://lens.xyz/docs/protocol/feeds/feedback)

## Edit a Post
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Edit a Post

This guide explains how to edit a Post content on Lens.

To update a Post on Lens, follow these steps.

You MUST be authenticated as Account Owner or Account Manager for the post
your are trying to edit.

1

## Check Post Rules

First, inspect the post.operations.canEdit field to determine whether the logged-in Account is allowed to edit the Post. Some posts may have restrictions on who can

```
switch (post.operations.canEdit.__typename) {  case "PostOperationValidationPassed":    // Commenting is allowed    break;
  case "PostOperationValidationFailed":    // Commenting is not allowed    console.log(post.operations.canEdit.reason);    break;
  case "PostOperationValidationUnknown":    // Validation outcome is unknown    break;}
```

Where:

- PostOperationValidationPassed: The logged-in Account is allowed to edit the Post.

- PostOperationValidationFailed: Editing is not allowed. The reason field explains why, and unsatisfiedRules lists the unmet requirements.

- PostOperationValidationUnknown: The Post or its Feed (for custom Feeds) has one or more _unknown rules_ requiring ad-hoc verification. The extraChecksRequired field provides the addresses and configurations of these rules.


Treat the PostOperationValidationUnknown as _failed_ unless you intend to
support the specific rules. See [Post Rules](https://lens.xyz/docs/protocol/feeds/post-rules) for more
information.

2

## Create Post Metadata

Next, if allowed, continue with creating a new Post Metadata object with the updated details.

It's developer responsability to copy over any existing data that should be
retained.

The process is similar to the one in the [Create a Post](https://lens.xyz/docs/protocol/feeds/post) guide, so we will keep this example brief.

```
import { textOnly } from "@lens-protocol/metadata";
const metadata = textOnly({  content: `GM! GM!`,});
```

3

## Upload Metadata

Next, upload the Post Metadata object to a public URI.

If the hosting solution used when the Post was created or last updated allows edits, you may want to choose between:

- Keeping a history of the file, like a document revision, by uploading it to a new URI.

- Erasing the previous version by updating the content at the same URI.


```
import { textOnly } from "@lens-protocol/metadata";import { storageClient } from "./storage-client";
const metadata = textOnly({  content: `GM! GM!`,});
const { uri } = await storageClient.uploadAsJson(metadata);
console.log(uri); // e.g., lens://4f91ca…
```

If [Grove storage](https://lens.xyz/docs/storage) was used you can decide if also metadata can
be edited and delete as needed. See the [Editing\\
Content](https://lens.xyz/docs/storage/usage/edit) and [Deleting\\
Content](https://lens.xyz/docs/storage/usage/delete) guides for more information.

4

## Update Post Content URI

Next, update the Post content URI with the new URI.

- TypeScript
- GraphQL
- React

Use the editPost action to update the Post content URI.

```
import { postId, uri } from "@lens-protocol/client";import { editPost } from "@lens-protocol/client/actions";
const result = await editPost(sessionClient, {  contentUri: uri("lens://4f91ca…"),  post: postId("42"),});
if (result.isErr()) {  return console.error(result.error);}
```

5

## Handle Result

- TypeScript
- GraphQL
- React

Finally, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await editPost(sessionClient, {  contentUri: uri("lens://4f91ca…"),  post: postId("01234…"),}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

[Previous\\
\\
**Fetch Posts**](https://lens.xyz/docs/protocol/feeds/fetch-posts) [Next\\
\\
**Delete a Post**](https://lens.xyz/docs/protocol/feeds/delete-post)

## Lens Protocol Storage
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Page not found.

Sorry. The page you're looking for can't be found.

Back to home

## Account Actions Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Account Actions

This guide will explain how to use Account Actions and how to implement custom ones.

Account Actions are contracts that extend the Lens Protocol functionality by allowing Accounts to execute actions on other Accounts.

## Tipping Account Action

Lens includes a built-in TippingAccountAction, which is enabled by default and allows an Account to tip another Account using any ERC20 token. Work is underway to add support for native GHO tipping (GRASS on the Lens Testnet).

The TippingAccountAction supports a referral scheme that lets you reward accounts or apps that helped surface the tipped Account.

A maximum of **20%** of the tipped amount can be allocated to referrals, but only if they're explicitly included when the tip is sent.

A **1.5%** Lens treasury fee is deducted from the total amount paid by the
tipper before calculating referral and recipient shares.

#### Referral Fee Breakdown

Let's say a user tips an Account with **100 GHO** using the TippingAccountAction.

Here's how the amount is split:

- **1.5 GHO** (1.5%) is deducted for the **Lens treasury fee**

- **98.5 GHO** remains


The user includes two referral recipients, fully allocating the maximum **20% referral fee** between them:

- 0xc0ffee with a **30% share** of the referral portion

- 0xbeef with a **70% share** of the referral portion


From the **98.5 GHO**:

- **19.7 GHO** (20%) is distributed as referrals:


- **5.91 GHO** to 0xc0ffee

- **13.79 GHO** to 0xbeef


- **78.8 GHO** is sent to the **tipped Account**


If the referral split adds up to less than 100% (e.g. a single referral with
50%), only the corresponding portion of the 20% referral fee will be used. The
unused remainder goes to the tipped Account.

## Custom Account Actions

Custom Account Actions must be configured on a per-account basis before they can be executed.

### Configuring Account Actions

To configure a custom Account Action, follow these steps.

You MUST be authenticated as Account Owner or Account Manager of the Account
you intend to configure an Account Action for.

1

#### Configure the Action

- TypeScript
- GraphQL

First, use the configureAccountAction action to configure a new Account Action.

```
import { blockchainData, evmAddress } from "@lens-protocol/client";import { configureAccountAction } from "@lens-protocol/client/actions";
const result = await configureAccountAction(sessionClient, {  action: {    unknown: {      address: evmAddress("0x1234…"),      params: [        {          raw: {            // 32 bytes key (e.g., keccak(name))            key: blockchainData("0xac5f04…"),            // an ABI encoded value            value: blockchainData("0x00"),          },        },      ],    },  },});
```

2

#### Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await configureAccountAction(sessionClient, {  action: {    // …  },}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

### Disabling Account Actions

To disable a custom Account Action, follow these steps.

You MUST be authenticated as Account Owner or Account Manager of the Account
you intend to configure an Account Action for.

1

#### Disable the Action

- TypeScript
- GraphQL

First, use the disableAccountAction action to disable an Account Action. You can re-enable it later using the enableAccountAction action.

```
import { blockchainData, evmAddress } from "@lens-protocol/client";import { disableAccountAction } from "@lens-protocol/client/actions";
const result = await disableAccountAction(sessionClient, {  unknown: {    address: evmAddress("0x1234…"),  },});
```

You can provide any parameters required by the custom Account Action contract
using the params field.

2

#### Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await disableAccountAction(sessionClient, {  unknown: {    address: evmAddress("0x1234…"),  },}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Executing Account Actions

To execute an Account Action, follow these steps.

You MUST be authenticated as Account Owner or Account Manager to execute an
Account Action.

1

### Inspect Account Actions

First, inspect the target account.actions field to determine what Account Actions are available on it.

```
for (const action of account.actions) {  switch (action.__typename) {    case "TippingAccountAction":      // The Account has a Tipping Account Action, all accounts have this by default      break;
    case "UnknownAction":      // The Account has a Custom Account Action      break;  }}
```

See some examples below.

```
{  "__typename": "TippingAccountAction",  "address": "0x5678…" // the address to tip}
```

2

### Execute Account Action

Next, execute the desired Account Action.

- TypeScript
- GraphQL
- React

Use the executeAccountAction action to execute an Account Action.

```
import { bigDecimal, evmAddress } from "@lens-protocol/client";import { executeAccountAction } from "@lens-protocol/client/actions";
const result = await executeAccountAction(sessionClient, {  account: evmAddress("0x1234…"),  action: {    tipping: {      currency: evmAddress("0x5678…"),      value: bigDecimal("100"),    },  },});
if (result.isErr()) {  return console.error(result.error);}
```

3

### Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await executeAccountAction(sessionClient, {  account: evmAddress("0x1234…"),  action: {    // …  },}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

That's it—you've successfully executed an Account Action.

## Building an Account Action

The Account Actions are defined by the IAccountAction interface, which basically requires three functions, one to configure the action, one to execute it, and another to disable it.

```
interface IAccountAction {    function configure(address originalMsgSender, address account, KeyValue[] calldata params)        external        returns (bytes memory);
    function execute(address originalMsgSender, address account, KeyValue[] calldata params)        external        returns (bytes memory);
    function setDisabled(address originalMsgSender, address account, bool isDisabled, KeyValue[] calldata params)        external        returns (bytes memory);}
```

### The ActionHub

Before we dive into each of the functions from the IAccountAction interface, we need to talk about the ActionHub.

The ActionHub is a special contract that acts as the entry point for every Action in the Lens Protocol.

The purpose of that is to help discovery of Actions, having a single point where all main Action-related events are emitted.

So, each function of the IAccountAction interface must be only callable by ActionHub. For this, you can inherit [BaseAccountAction contract](https://github.com/lens-protocol/lens-v3/blob/development/contracts/actions/account/base/BaseAccountAction.sol), which acts as template for your custom Post Action, applying the restrictions needed, so you do not need to worry about it.

With this context, you can now understand why the first param of every IAccountAction function is originalMsgSender: this is the address that called the ActionHub originally, either to configure, execute, or disable an Action, given that msg.sender will always have the ActionHub address in the context of your Action contract.

### Configuration

The configuration of the Action is done through the configure function, which purpose is to initialize any required state that the Action might require to work properly.

The function receives three parameters:

- originalMsgSender: the address of the original msg.sender that invoked the ActionHub (as explained above).

- account: the address of the Account for which the Action is configured for.

- params: array of key-value pairs whose values can be decoded into any extra custom configuration parameters that the Action could require to work.


Return of the configure function is bytes - some Actions might want to return custom information to the caller.

This configure function could be called by anyone (through the ActionHub, as explained above), it will depend on the implementation of the Action and its purpose who is allowed to invoke it (based on originalMsgSender).

For example, there might be Actions that do not require initialization at all, so the configure function implementation will be empty, while other Actions might require the caller to match the Account for which the actions is being configured for (i.e. being configured by the Account itself).

Keep in mind that if no prior configuration is required, the configure
function must still be implemented and must not revert.

Every time the configure function is called, the ActionHub will emit a Lens\_ActionHub\_AccountAction\_Configured event matching the parameters of the call (or Lens\_ActionHub\_AccountAction\_Reconfigured if the configuration was updated).

### Execution

The execution of the Action is done through the execute function, which purpose is to perform the actual action logic that the Action implements.

The function receives three parameters:

- originalMsgSender: the address of the original msg.sender that invoked the ActionHub (as explained above).

- account: the address of the Account for which the Action is being executed.

- params: array of key-value pairs whose values can be decoded into any extra custom execution parameters that the Action could require to work.


Return of the execute function is bytes - some Actions might want to return custom information to the caller.

This execute function could be called by anyone (through the ActionHub, as explained above), it will depend on the implementation of the Action and its purpose who is allowed to invoke it (based on originalMsgSender).

For example, there might be Actions that do not require any permissions at all, so the execute function implementation will be open, while other Actions might require the caller to match the some specific address.

Every time the execute function is called, the ActionHub will emit a Lens\_ActionHub\_AccountAction\_Executed event matching the parameters of the call.

The ActionHub will not allow to invoke the execute function on an Account if
the Action is disabled for it.

### Disabling

The disabling of the Action is done through the setDisabled function, which purpose is to stop an Action to be executable for a given Account. The same function can be used to enable the Action back.

The function receives four parameters:

- originalMsgSender: the address of the original msg.sender that invoked the ActionHub (as explained above).

- account: the address of the Account for which the Action is being disabled/enabled.

- isDisabled: boolean indicating if the Action is being disabled or enabled.

- params: array of key-value pairs whose values can be decoded into any extra custom disabling/enabling parameters that the Action could require to work.


Return of the setDisabled function is bytes - some Actions might want to return custom information to the caller.

This setDisabled function could be called by anyone (through the ActionHub, as explained above), it will depend on the implementation of the Action and its purpose who is allowed to invoke it (based on originalMsgSender).

Every time the setDisabled function is called, the ActionHub will emit a Lens\_ActionHub\_AccountAction\_Disabled event matching the parameters of the call.

### Example

Let's create an Pay-To-Repost Account Action that allows anyone to pay a fixed for the Account to repost a given Post.

1

#### Define State Variables

First, we define the necessary state variables. We need a mapping \_prices to store the price configured by each account for a specific token. This same array can also act as an indicator if the action was configured (i.e. if the price is 0, it means the action was not configured for that account).

```
/** * @title SimplePayToReAccountAction * @notice A simple Account action allowing users to pay for the Account to repost a given post. */contract SimplePayToReAccountAction is BaseAccountAction, LensPaymentHandler {    // account => token => price    mapping(address => mapping(address => uint256)) private _prices;
```

2

#### Implement the Configure Function

Next, implement the \_configure function. This function allows the account owner (originalMsgSender) to set the price for reposting using their account. It extracts the payment token and price from the params array.

It includes checks to ensure:

1. Only the account owner can configure it (originalMsgSender == account).

2. This action contract is set as an Account Manager for the target account, as it needs permission to execute the repost later.

3. A valid token address and a price > 0 are provided.


```
// ... inside SimplePayToReAccountAction ...
    function _configure(        address originalMsgSender,        address account,        KeyValue[] calldata params    ) internal override returns (bytes memory) {        require(originalMsgSender == account, "Only account can configure");        require(IAccount(account).canExecuteTransactions(address(this)), "SimplePayToReAccountAction is not set as AccountManager");
        address token;        uint256 price = 0;        for (uint256 i = 0; i < params.length; i++) {          if (params[i].key == keccak256("lens.param.token")) {              token = abi.decode(params[i].value, (address));          } else if (params[i].key == keccak256("lens.param.price")) {              price = abi.decode(params[i].value, (uint256));          }        }
        require(token != address(0), "Token not found in params");        IERC20(token).balanceOf(address(this)); // Just checking if the token is valid        require(price > 0, "Valid price not found in params");
        _prices[account][token] = price;
        // Emitting an event Lens_ActionHub_AccountAction_Configured happens automatically via ActionHub        return "";    }
```

3

#### Implement the Execute Function

Implement the \_execute function. This allows any user (originalMsgSender) to pay the configured price to make the account repost a specific post.

The function extracts the target feed, postId, payment token, and the expectedPrice from the params. It verifies that the expectedPrice matches the price configured by the account owner.

It then uses the inherited \_handlePayment function (from LensPaymentHandler) to process the payment from the originalMsgSender to the account.

Finally, it executes the repost on behalf of the account by calling the repost function on the target IFeed interface. This requires the action contract to have been approved as an Account Manager during configuration.

```
// ... inside SimplePayToReAccountAction ...
    function _execute(        address originalMsgSender,        address account,        KeyValue[] calldata params    ) external override returns (bytes memory) {        address feed;        uint256 postId;        address token;        uint256 expectedPrice;        for (uint256 i = 0; i < params.length; i++) {          if (params[i].key == keccak256("lens.param.feed")) {              feed = abi.decode(params[i].value, (address));          } else if (params[i].key == keccak256("lens.param.postId")) {              postId = abi.decode(params[i].value, (uint256));          } else if (params[i].key == keccak256("lens.param.token")) {              token = abi.decode(params[i].value, (address));          } else if (params[i].key == keccak256("lens.param.expectedPrice")) {              expectedPrice = abi.decode(params[i].value, (uint256));          }        }        require(expectedPrice > 0, "Valid expected price not found in params");        require(_prices[account][token] == expectedPrice, "Not configured or wrong price expected");
        // Function located at LensPaymentHandler contract:        _handlePayment({            payer: originalMsgSender,            token: token,            amount: expectedPrice,            recipient: account,            referrals: new RecipientData[](0),            referralFeeBps: 0        });
        uint256 repostId = IFeed(feed).repost({          postParams: CreatePostParams({              author: account,              contentURI: "",              repostedPostId: postId,              quotedPostId: 0,              repliedPostId: 0,              ruleChanges: new RuleChange[](0),              extraData: new KeyValue[](0)          }),          customParams: new KeyValue[](0),          feedRulesParams: new RuleProcessingParams[](0),          rootPostRulesParams: new RuleProcessingParams[](0),          quotedPostRulesParams: new RuleProcessingParams[](0),        });
        return abi.encode(repostId);    }
```

After adding the corresponding imports, our final code should look something like this:

```
// SPDX-License-Identifier: MITpragma solidity ^0.8.20;
import { KeyValue } from "contracts/core/Types.sol";import { BaseAccountAction } from "contracts/actions/account/base/BaseAccountAction.sol";import { IFeed } from "contracts/core/interfaces/IFeed.sol";import { LensPaymentHandler } from "contracts/extensions/fees/LensPaymentHandler.sol";
/** * @title SimplePayToReAccountAction * @notice A simple Account action allowing users to pay for the Account to repost a given post. */contract SimplePayToReAccountAction is BaseAccountAction, LensPaymentHandler {    mapping(address account => mapping(address token => uint256 price))) private _prices;
    /**      * @notice Configures the SimplePayToReAccount Action for a given post.      * @param originalMsgSender The address initiating the configuration via the ActionHub. Must be post the account.      * @param account The address of the account that configures the Pay-To-Repost for itself.      * @param params KeyValue array containing the token and price configuration parameters.      * @return bytes abi.encoded(token, price).     */    function _configure(        address originalMsgSender,        address account,        KeyValue[] calldata params    ) internal override returns (bytes memory) {        require(originalMsgSender == account, "Only account can configure");        require(IAccount(account).canExecuteTransactions(address(this)), "SimplePayToReAccountAction is not set as AccountManager");
        address token;        uint256 price = 0;        for (uint256 i = 0; i < params.length; i++) {          if (params[i].key == keccak256("lens.param.token")) {              token = abi.decode(params[i].value, (address));          } else if (params[i].key == keccak256("lens.param.price")) {              price = abi.decode(params[i].value, (uint256));          }        }
        require(token != address(0), "Token not found in params");        IERC20(token).balanceOf(address(this)); // Just checking if the token is valid        require(price > 0, "Valid price not found in params");
        _prices[account][token] = price;
        // Emitting an event Lens_ActionHub_AccountAction_Configured happens automatically via ActionHub and params        // already contain token & price, so we don't have to encode them again for emitting.        return "";    }
    /**     * @notice Executes a repost of a given post by a configured Account.     * @param originalMsgSender The address initiating the repost via the ActionHub.     * @param account The address of the account where the Pay-To-Repost Action was configured.     * @param params Array of key-value pairs. Expected to contain the feed and postId to repost.     * @return bytes feed and post.     * Requirements:     * - The `originalMsgSender` must not have voted on this `postId` before.     * - `params` must not be empty and the first element's value must be abi-decodable as a boolean.     */    function _execute(        address originalMsgSender,        address account,        KeyValue[] calldata params    ) external override returns (bytes memory) {        address feed;        uint256 postId;        address token;        uint256 expectedPrice;        for (uint256 i = 0; i < params.length; i++) {          if (params[i].key == keccak256("lens.param.feed")) {              feed = abi.decode(params[i].value, (address));          } else if (params[i].key == keccak256("lens.param.postId")) {              postId = abi.decode(params[i].value, (uint256));          } else if (params[i].key == keccak256("lens.param.token")) {              token = abi.decode(params[i].value, (address));          } else if (params[i].key == keccak256("lens.param.expectedPrice")) {              expectedPrice = abi.decode(params[i].value, (uint256));          }        }        require(expectedPrice > 0, "Valid expected price not found in params");        require(_prices[account][token] == expectedPrice, "Not configured or wrong price expected");
        // Function located at LensPaymentHandler contract:        _handlePayment({            payer: originalMsgSender,            token: token,            amount: expectedPrice,            recipient: account,            referrals: new RecipientData[](0),            referralFeeBps: 0        });
        uint256 repostId = IFeed(feed).repost({          postParams: CreatePostParams({              author: account,              contentURI: "",              repostedPostId: postId,              quotedPostId: 0,              repliedPostId: 0,              ruleChanges: new RuleChange[](0),              extraData: new KeyValue[](0)          }),          customParams: new KeyValue[](0),          feedRulesParams: new RuleProcessingParams[](0),          rootPostRulesParams: new RuleProcessingParams[](0),          quotedPostRulesParams: new RuleProcessingParams[](0),        });
        return abi.encode(repostId);    }}
```

[Previous\\
\\
**Block Accounts**](https://lens.xyz/docs/protocol/accounts/block) [Next\\
\\
**Account Funds**](https://lens.xyz/docs/protocol/accounts/funds)

## Lens Protocol Overview
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Page not found.

Sorry. The page you're looking for can't be found.

Back to home

## Username Namespace Rules
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Namespace Rules

This guide explains how to use username Namespace Rules and how to implement custom ones.

Namespace Rules allow administrators to add requirements or constraints that will be applied when a Username in a given Namespace is created or assigned to an Account.

Lens provides three built-in Group rules:

- UsernamePricePerLengthNamespaceRule \- Requires an ERC-20 payment to create a Username.

- TokenGatedNamespaceRule \- Requires an account to hold a certain token to create a Username.

- UsernameLengthNamespaceRule \- Restricts the length of Usernames.


For the UsernamePricePerLengthNamespaceRule, a **1.5%** Lens treasury fee is
deducted from the payment before the remaining amount is transferred to the
designated recipient.

To keep usernames web-friendly across the ecosystem, the Namespace primitive enforces a **maximum length of 255 characters**.

Two additional built-in rules are also applied by default to every new Namespace:

- UsernameReservedNamespaceRule \- This rule allows the Namespace owner or admins to reserve a specific set of usernames. See [Reserved Usernames](https://lens.xyz/docs/protocol/usernames/reserved-usernames) for more information.

- UsernameSimpleCharsetNamespaceRule \- This rule limits valid characters to a-z, 0-9, -, and \_, ensuring consistency. Usernames cannot begin with - or \_.


## Using Namespace Rules

As part of creating [Custom Namespaces](https://lens.xyz/docs/protocol/usernames/custom-namespaces), you can pass a rules object that defines the required rules and/or an anyOf set, where satisfying any one rule allows the Username creation or assignment to succeed. These rules can be built-in or custom.

This section presumes you are familiar with the process of [creating a\\
Namespace](https://lens.xyz/docs/protocol/usernames/custom-namespaces) on Lens.

### Username Price per Length Namespace Rule

This rule can be applied to a Username namespace to require an ERC-20 payment based on the length of the Username being created.

- TypeScript
- GraphQL
- React

```
import { bigDecimal, evmAddress } from "@lens-protocol/client";import { createUsernameNamespace } from "@lens-protocol/client/action";
const result = await createUsernameNamespace(sessionClient, {  symbol: "FOO",  namespace: "foo",  rules: {    required: [      {        usernamePricePerLengthRule: {          cost: {            currency: evmAddress("0x5678…"),            value: bigDecimal('0.5'), // Token value in its main unit          },          recipient: evmAddress("0x1234…"),          costOverrides: [            {              amount: bigDecimal('5'),              length: 1,            },            {              amount: bigDecimal('4'),              length: 2,            },            {              amount: bigDecimal('3'),              length: 3,            },            {              amount: bigDecimal('2'),              length: 4,            }          ]        }      }    ],});
```

### Token Gated Namespace Rule

This rule requires holding a certain balance of a token (fungible or non-fungible) to create a Username.

Configuration includes the token address, the token standard (ERC-20, ERC-721, or ERC-1155), and the required token amount. For ERC-1155 tokens, an additional token type ID is required.

- TypeScript
- GraphQL
- React

```
import { bigDecimal, evmAddress, } from "@lens-protocol/client";import { createUsernameNamespace } from "@lens-protocol/client/action";
const result = await createUsernameNamespace(sessionClient, {  symbol: "FOO",  namespace: "foo",  rules: {    required: [      {        tokenGatedRule: {          token: {            currency: evmAddress("0x1234…"),            standard: TokenStandard.Erc721,            value: bigDecimal("1"),          },        },      }    ],});
```

### Username Length Namespace Rule

This rule can restricts the minimum and/or maximum length of Usernames.

- TypeScript
- GraphQL
- React

```
import { bigDecimal, evmAddress } from "@lens-protocol/client";import { createUsernameNamespace } from "@lens-protocol/client/action";
const result = await createUsernameNamespace(sessionClient, {  symbol: "FOO",  namespace: "foo",  rules: {    required: [      {        usernameLengthRule: {          minLength: 3,          maxLength: 10,        },      },    ],  },});
```

### Custom Namespace Rule

You can also use custom rules by specifying the rule contract address, when it applies, and the configuration parameters as key-value pairs.

- TypeScript
- GraphQL
- React

```
import {  blockchainData,  evmAddress,  NamespaceRuleExecuteOn,} from "@lens-protocol/client";import { createUsernameNamespace } from "@lens-protocol/client/action";
const result = await createUsernameNamespace(sessionClient, {  symbol: "FOO",  namespace: "foo",  rules: {    required: [      {        unknownRule: {          address: evmAddress("0x1234…"),          executeOn: [            NamespaceRuleExecuteOn.Creating,            NamespaceRuleExecuteOn.Assigning,          ],          params: [            {              raw: {                // 32 bytes key (e.g., keccak(name))                key: blockchainData("0xac5f04…"),                // an ABI encoded value                value: blockchainData("0x00"),              },            },          ],        },      },    ],  },});
```

### Update a Namespace Rules

To update a Namespace rules configuration, follow these steps.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) and be either the
owner or an admin of the Namespace you intend to configure.

1

#### Identify Current Rules

First, inspect the namespace.rules field to know the current rules configuration.

- TypeScript
- GraphQL

```
type NamespaceRules = {  required: NamespaceRule;  anyOf: NamespaceRule;};
```

Keep note of the Rule IDs you might want to remove.

2

#### Update the Rules Configuration

Next, update the rules configuration of the Namespace as follows.

- TypeScript
- GraphQL
- React

Use the updateNamespaceRules action to update the rules configuration of a given namespace.

```
import { bigDecimal, evmAddress } from "@lens-protocol/client";import { updateNamespaceRules } from "@lens-protocol/client/action";
const result = await updateNamespaceRules(sessionClient, {  namespace: namespace.address,  toAdd: {    required: [      {        tokenGatedRule: {          token: {            standard: TokenStandard.Erc20,            currency: evmAddress("0x5678…"),            value: bigDecimal("1.5"), // Token value in its main unit          },        },      },    ],  },});
```

3

#### Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await updateNamespaceRules(sessionClient, {  namespace: evmAddress("0x1234…"),  // …}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Building a Namespace Rule

Let's illustrate the process with an example. We will build a custom Namespace Rule that requires Usernames to be created only if their length has an specific parity, for example, all usernames must have an even length.

To build a custom Namespace Rule, you must implement the following INamespaceRule interface:

```
import {KeyValue} from "contracts/core/types/Types.sol";
interface INamespaceRule {    function configure(bytes32 configSalt, KeyValue[] calldata ruleParams) external;
    function processCreation(        bytes32 configSalt,        address originalMsgSender,        address account,        string calldata username,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external;
    function processRemoval(        bytes32 configSalt,        address originalMsgSender,        string calldata username,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external;
    function processAssigning(        bytes32 configSalt,        address originalMsgSender,        address account,        string calldata username,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external;
    function processUnassigning(        bytes32 configSalt,        address originalMsgSender,        address account,        string calldata username,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external;}
```

Each function of this interface must assume to be invoked by the Namespace
contract. In other words, assume the msg.sender will be the Namespace contract.

A Lens dependency package with all relevant interfaces will be available soon.

1

### Implement the Configure Function

First, implement the configure function. This function has the purpose of initializing any required state for the rule to work properly.

It receives two parameters, a 32-byte configuration salt (configSalt), and an array of custom parameters as key-value pairs (ruleParams).

The configSalt is there to allow the same rule contract to be used many times, with different configurations, for the same Namespace. So, for a given Namespace Rule implementation, the pair (Namespace Address, Configuration Salt) should identify a rule configuration.

The configure function can be called multiple times by the same Namespace passing the same configuration salt in
order to update that rule configuration (i.e. reconfigure it).

The ruleParams is an array of key-value pairs that can be used to pass any custom configuration parameters to the rule. Each key is bytes32, we put the hash of the parameter name there, and each value is bytes, we set the ABI-encoded parameter value there. Given that ruleParams is an array, this allows the rule to define which parameters are optional and which are required, acting accordingly when any of them are not present.

In our example, we only need to decode a boolean parameter, which will indicate if the rule will enforce Usernames to have an even or an odd length. Let's define a storage mapping to store this configuration:

```
contract UsernameParityLengthNamespaceRule is INamespaceRule {    mapping(address namespace => mapping(bytes32 configSalt => bool mustBeEven)) internal _mustBeEvenLength;}
```

The configuration is stored in the mapping using the Namespace contract address (msg.sender) and the configuration salt as keys. With this setup, the same rule can be used by different Namespaces, as well as be used by the same Namespace many times.

Now let's code the configure function itself, decoding the boolean parameter and storing it in the mapping:

```
contract UsernameParityLengthNamespaceRule is INamespaceRule {    mapping(address namespace => mapping(bytes32 configSalt => bool mustBeEven)) internal _mustBeEvenLength;
    function configure(bytes32 configSalt, KeyValue[] calldata ruleParams) external override {        bool mustBeEven = true; // We set `true` as default value        for (uint256 i = 0; i < ruleParams.length; i++) {            if (ruleParams[i].key == keccak256("lens.param.mustBeEven")) {                mustBeEven = abi.decode(ruleParams[i].value, (bool));                break;            }        }        _mustBeEvenLength[msg.sender][configSalt] = mustBeEven;    }}
```

We treated the mustBeEven parameter as optional, defaulting to true (even length) when not present.

2

### Implement the Process Creation function

Next, implement the processCreation function. This function is invoked by the Namespace contract every time a username is being created, so then our custom logic can be applied to shape under which conditions this operation can succeed.

The function receives the configuration salt (configSalt), the address that is trying to create the Username (originalMsgSender), the account who will own the created Username, the username being created, an array of key-value pairs with the custom parameters passed to the Namespace (primitiveParams), and an array of key-value pairs in case the rule requires additional parameters to work (ruleParams).

The function must revert if the requirements imposed by the rule are not met.

```
contract UsernameParityLengthNamespaceRule is INamespaceRule {    mapping(address namespace => mapping(bytes32 configSalt => bool mustBeEven)) internal _mustBeEvenLength;
    // ...
    function processCreation(        bytes32 configSalt,        address originalMsgSender,        address account,        string calldata username,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external view override {        // Retrieve the rule configuration        bool mustBeEven = _mustBeEvenLength[msg.sender][configSalt];
        // Get the length of the username being created        uint256 usernameLength = bytes(username).length;
        // Check if the length is even (otherwise it is odd)        bool isEvenLength = usernameLength % 2 == 0;
        // Require the parity of the username being created to match        // the parity required by the rule        require(isEvenLength == mustBeEven);    }
    // ...}
```

3

### Implement the Process Removal function

Next, implement the processRemoval function. This function is invoked by the Namespace contract every time a username is being removed.

The function receives the configuration salt (configSalt), the address that is trying to remove the Username (originalMsgSender), the username being removed, an array of key-value pairs with the custom parameters passed to the Namespace (primitiveParams), and an array of key-value pairs in case the rule requires additional parameters to work (ruleParams).

The function must revert if the requirements imposed by the rule are not met. In our example, the parity rule does not apply to removal, so we revert with NotImplemented. This is good practice in case the rule is accidentally enabled for this selector.

```
contract UsernameParityLengthNamespaceRule is INamespaceRule {
    // ...
    function processRemoval(        bytes32 configSalt,        address originalMsgSender,        string calldata username,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external pure override {        revert Errors.NotImplemented();    }
    // ...}
```

4

### Implement the Process Assigning function

Next, implement the processAssigning function. This function is invoked by the Namespace contract every time a username is being assigned to an account.

The function receives the configuration salt (configSalt), the address that is trying to assign the Username (originalMsgSender), the account who the username will be assigned to, the username being assigned, an array of key-value pairs with the custom parameters passed to the Namespace (primitiveParams), and an array of key-value pairs in case the rule requires additional parameters to work (ruleParams).

The function must revert if the requirements imposed by the rule are not met. Similar to removal, our parity rule does not apply to the assignment operation, so we revert with NotImplemented.

```
contract UsernameParityLengthNamespaceRule is INamespaceRule {
    // ...
    function processAssigning(        bytes32 configSalt,        address originalMsgSender,        address account,        string calldata username,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external pure override {        revert Errors.NotImplemented();    }
    // ...}
```

5

### Implement the Process Unassigning function

Finally, implement the processUnassigning function. This function is invoked by the Namespace contract every time a username is being unassigned from an account.

The function receives the configuration salt (configSalt), the address that is trying to unassign the Username (originalMsgSender), the account who the username will be unassigned from, the username being unassigned, an array of key-value pairs with the custom parameters passed to the Namespace (primitiveParams), and an array of key-value pairs in case the rule requires additional parameters to work (ruleParams).

The function must revert if the requirements imposed by the rule are not met. Again, our parity rule does not apply to the unassigning process, so we revert with NotImplemented.

```
contract UsernameParityLengthNamespaceRule is INamespaceRule {
    // ...
    function processUnassigning(        bytes32 configSalt,        address originalMsgSender,        address account,        string calldata username,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external pure override {        revert Errors.NotImplemented();    }}
```

Now the UsernameParityLengthNamespaceRule is ready to be applied to any Namespace. See the full code below:

```
contract UsernameParityLengthNamespaceRule is INamespaceRule {
    mapping(address => mapping(bytes32 => bool)) internal _mustBeEvenLength;
    function configure(bytes32 configSalt, KeyValue[] calldata ruleParams) external override {        bool mustBeEven = true; // We set `true` as default value        for (uint256 i = 0; i < ruleParams.length; i++) {            if (ruleParams[i].key == keccak256("lens.param.mustBeEven")) {                mustBeEven = abi.decode(ruleParams[i].value, (bool));                break;            }        }        _mustBeEvenLength[msg.sender][configSalt] = mustBeEven;    }
    function processCreation(        bytes32 configSalt,        address originalMsgSender,        address account,        string calldata username,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external view override {        // Retrieve the rule configuration        bool mustBeEven = _mustBeEvenLength[msg.sender][configSalt];
        // Get the length of the username being created        uint256 usernameLength = bytes(username).length;
        // Check if the length is even (otherwise it is odd)        bool isEvenLength = usernameLength % 2 == 0;
        // Require the parity of the username being created to match        // the parity required by the rule        require(isEvenLength == mustBeEven);    }
    function processRemoval(        bytes32 configSalt,        address originalMsgSender,        string calldata username,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external pure override {        revert Errors.NotImplemented();    }
    function processAssigning(        bytes32 configSalt,        address originalMsgSender,        address account,        string calldata username,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external pure override {        revert Errors.NotImplemented();    }
    function processUnassigning(        bytes32 configSalt,        address originalMsgSender,        address account,        string calldata username,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external pure override {        revert Errors.NotImplemented();    }}
```

Stay tuned for API integration of rules and more guides!

[Previous\\
\\
**Reserved Usernames**](https://lens.xyz/docs/protocol/usernames/reserved-usernames) [Next\\
\\
**Groups**](https://lens.xyz/docs/protocol/groups/create)

## Lens Protocol Feeds
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Page not found.

Sorry. The page you're looking for can't be found.

Back to home

## Funding Sponsorships Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Funding Sponsorships

This guide covers how to fund your Lens Sponsorship contract.

To sponsor transactions for your users, you need to periodically fund your Lens Sponsorship.

You can do this by sending native tokens (e.g., _$GRASS_ on Testnet) to the Lens Sponsorship contract address.

This can be done either through a wallet or programmatically via code.

```
import { ethers } from "ethers";
import { wallet } from "./wallet";
const response = await wallet.sendTransaction({  to: "<SPONSORSHIP_ADDRESS>",  value: ethers.parseEther("100"), // Amount in native tokens});
const receipt = await response.wait();
// funded
```

Refer to the Lens Chain [integration guide](https://lens.xyz/docs/chain/integrations/viem) for
more options on how to integrate with the Lens Chain.

[Next\\
\\
**Overview**](https://lens.xyz/docs/protocol)

## Group Rules Overview
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Group Rules

This guide explains how to use Group Rules and how to implement custom ones.

Group Rules allow administrators to add requirements or constraints for joining or leaving a Group.

Lens provides four built-in Group rules:

- SimplePaymentGroupRule \- Requires an ERC-20 payment to join the Group.

- TokenGatedGroupRule \- Requires an account to hold a certain token to join the Group.

- MembershipApprovalGroupRule \- Requires approval by owner or administrators of the Group to join.

- BanMemberGroupRule \- Prevents an account from joining the Group if banned.

- AdditionRemovalPidGroupRule \- Requires an account to have special permissions (typically equivalent to be Owner or Admin) in order to add or remove members from the Group.


For the SimplePaymentGroupRule, a **1.5%** Lens treasury fee is deducted
from the payment before the remaining amount is transferred to the designated
recipient.

It is also possible to use custom Group Rules to extend the functionality of your Group.

## Using Group Rules

This section presumes you are familiar with the process of [creating a\\
Group](https://lens.xyz/docs/protocol/groups/create) on Lens.

### Simple Payment Group Rule

This rule requires an ERC-20 payment to join a Group. Configuration includes the ERC-20 token address, the payment amount, and the recipient address.

- TypeScript
- GraphQL
- React

```
import { bigDecimal, evmAddress, uri } from "@lens-protocol/client";import { createGroup } from "@lens-protocol/client/actions";
const result = await createGroup(sessionClient, {  metadataUri: uri("lens://4f91c…"),  rules: {    required: [      {        simplePaymentRule: {          cost: {            currency: evmAddress("0x5678…"),            value: bigDecimal("10.42"),          },          recipient: evmAddress("0x9012…"),        },      },    ],  },});
```

### Token Gated Group Rule

This rule requires holding a certain balance of a token (fungible or non-fungible) to join a Group.

Configuration includes the token address, the token standard (ERC-20, ERC-721, or ERC-1155), and the required token amount. For ERC-1155 tokens, an additional token type ID is required.

- TypeScript
- GraphQL
- React

```
import {  bigDecimal,  evmAddress,  uri,  TokenStandard,} from "@lens-protocol/client";import { createGroup } from "@lens-protocol/client/actions";
const result = await createGroup(sessionClient, {  metadataUri: uri("lens://4f91c…"),  rules: {    required: [      {        tokenGatedRule: {          token: {            currency: evmAddress("0x1234…"),            standard: TokenStandard.Erc721,            value: bigDecimal("1"),          },        },      },    ],  },});
```

### Membership Approval Group Rule

This rule requires approval by the owner or administrators to join a Group.

- TypeScript
- GraphQL
- React

```
import {  bigDecimal,  evmAddress,  uri,  TokenStandard,} from "@lens-protocol/client";import { createGroup } from "@lens-protocol/client/actions";
const result = await createGroup(sessionClient, {  metadataUri: uri("lens://4f91c…"),  rules: {    required: [{ membershipApprovalRule: { enable: true } }],  },});
```

See the [Membership Approvals](https://lens.xyz/docs/protocol/groups/membership-approvals) guide for more information on how to handle membership approval.

### Ban Member Group Rule

This rule prevents an account from joining a Group and is automatically enabled when a Group is created.

See the [Banned Accounts](https://lens.xyz/docs/protocol/groups/banned-accounts) guide for more information on how to handle banned accounts.

### Custom Group Rules

You can also use custom rules by specifying the rule contract address, when it applies, and the configuration parameters as key-value pairs.

- TypeScript
- GraphQL
- React

```
import {  blockchainData,  evmAddress,  GroupRuleExecuteOn,  uri,} from "@lens-protocol/client";import { createGroup } from "@lens-protocol/client/actions";
const result = await createGroup(sessionClient, {  metadataUri: uri("lens://4f91c…"),  rules: {    required: [      {        unknownRule: {          address: evmAddress("0x1234…"),          executeOn: [GroupRuleExecuteOn.Joining],          params: [            {              raw: {                // 32 bytes key (e.g., keccak(name))                key: blockchainData("0xac5f04…"),                // an ABI encoded value                value: blockchainData("0x00"),              },            },          ],        },      },    ],  },});
```

### Combining Rules

Additionally, multiple rules can be combined:

- TypeScript
- GraphQL
- React

```
import {  bigDecimal,  evmAddress,  TokenStandard,  uri,} from "@lens-protocol/client";import { createGroup } from "@lens-protocol/client/actions";
const result = await createGroup(sessionClient, {  metadataUri: uri("lens://4f91c…"),  rules: {    required: [      {        simplePaymentRule: {          cost: {            currency: evmAddress("0x5678…"),            value: bigDecimal("10.42"),          },          recipient: evmAddress("0x9012…"),        },      },    ],    anyOf: [      {        tokenGatedRule: {          token: {            currency: evmAddress("0x1234…"),            standard: TokenStandard.Erc721,            value: bigDecimal("1"),          },        },      },      {        tokenGatedRule: {          token: {            currency: evmAddress("0x3456…"),            standard: TokenStandard.Erc721,            value: bigDecimal("1"),          },        },      },    ],  },});
```

### Update a Group Rules

To update a Group rules configuration, follow these steps.

You MUST be authenticated as a [Builder](https://lens.xyz/docs/protocol/authentication), Account Manager,
or Account Owner and be either the owner or an admin of the Group to update
its rules.

1

#### Identify Current Rules

First, inspect the:

- group.banningEnabled flag to know if the Group has the BanMemberGroupRule enabled.

- group.membershipApprovalEnabled flag to know if the Group has the MembershipApprovalGroupRule enabled.


And inspect the group.rules field to know details on all rules configuration of the Group.

- TypeScript
- GraphQL

```
type GroupRules = {  __typename: "GroupRules";  required: GroupRule[];  anyOf: GroupRule[];};
```

The configuration for the built-in rules with one or more parameters is as follows.

- SimplePaymentGroupRule
- TokenGatedGroupRule

| Key | Type | Description |  |
| --- | --- | --- | --- |
| assetContract | EvmAddress | Address of the ERC-20 token contract. |  |
| assetName | String | Name of the ERC-20 token. |  |
| assetSymbol | String | Symbol of the ERC-20 token. |  |
| amount | BigDecimal | Minimum amount of the ERC-20 token required to join. |  |

Keep note of the Rule IDs you might want to remove.

2

#### Update the Rules Configuration

Next, update the rules configuration of the Group as follows.

- TypeScript
- GraphQL
- React

Use the updateGroupRules action to update the rules configuration of a given group.

```
import { bigDecimal, evmAddress, TokenStandard } from "@lens-protocol/client";import { updateGroupRules } from "@lens-protocol/client/action";
const result = await updateGroupRules(sessionClient, {  group: group.address,  toAdd: {    required: [      {        tokenGatedRule: {          token: {            currency: evmAddress("0x1234…"),            standard: TokenStandard.Erc721,            value: bigDecimal("1"),          },        },      },    ],  },});
```

3

#### Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await updateGroupRules({} as SessionClient, {  group: group.address,  // …}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Building a Group Rule

Let's illustrate the process with an example. We will build a custom Group Rule that requires accounts to have more than a certain amount of Followers in order to join the Group.

To build a custom Group Rule, you must implement the following IGroupRule interface:

```
interface IGroupRule {    function configure(bytes32 configSalt, KeyValue[] calldata ruleParams) external;
    function processAddition(        bytes32 configSalt,        address originalMsgSender,        address account,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external;
    function processRemoval(        bytes32 configSalt,        address originalMsgSender,        address account,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external;
    function processJoining(        bytes32 configSalt,        address account,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external;
    function processLeaving(        bytes32 configSalt,        address account,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external;}
```

Each function of this interface must assume to be invoked by the Group
contract. In other words, assume the msg.sender will be the Group contract.

A Lens dependency package with all relevant interfaces will be available soon.

1

### Implement the Configure Function

First, implement the configure function. This function has the purpose of initializing any required state for the rule to work properly.

It receives two parameters, a 32-byte configuration salt (configSalt), and an array of custom parameters as key-value pairs (ruleParams).

The configSalt is there to allow the same rule contract to be used many times, with different configurations, for the same Group. So, for a given Group Rule implementation, the pair (Group Address, Configuration Salt) should identify a rule configuration.

For example, let's think about the TokenGatedGroupRule, we could want to achieve the restriction "To join this Group, you must hold 10 WETH and 1 WBTC". However, the TokenGatedGroupRule only allows to configure a single token as a gate. So, instead of writing a whole new contract that receives two tokens instead of one, we would just configure the TokenGatedGroupRule rule twice in the same Group, once for WETH with some configuration salt, and once for WBTC with another configuration salt.

The configure function can be called multiple times by the same Group passing the same configuration salt in
order to update that rule configuration (i.e. reconfigure it).

The ruleParams is an array of key-value pairs that can be used to pass any custom configuration parameters to the rule. Each key is bytes32, we put the hash of the parameter name there, and each value is bytes, we set the ABI-encoded parameter value there. Given that ruleParams is an array, this allows the rule to define which parameters are optional and which are required, acting accordingly when any of them are not present.

In our example, we need to decode two parameters: an address, representing the Graph where to perform the amount of followers check, and an integer, which will represent the minimum amount of Followers an account must have in order to become a member of the Group. Let's define a storage mapping to store this configuration:

```
contract FollowerCountGatedGroupRule is IGroupRule {    mapping(address group => mapping(bytes32 configSalt => address graph)) internal _graphToCheck;    mapping(address group => mapping(bytes32 configSalt => uint256 minFollowers)) internal _minFollowers;}
```

The configuration is stored in the mapping using the Group contract address and the configuration salt as keys. With this setup, the same rule can be used by different Groups, as well as be used by the same Group many times.

Now let's code the configure function itself, decoding the parameters and putting them into the storage:

```
contract FollowerCountGatedGroupRule is IGroupRule {    mapping(address group => mapping(bytes32 configSalt => address graph)) internal _graphToCheck;    mapping(address group => mapping(bytes32 configSalt => uint256 minFollowers)) internal _minFollowers;
    function configure(bytes32 configSalt, KeyValue[] calldata ruleParams) external override {        address graphToCheck;        uint256 minFollowers = 100;        for (uint256 i = 0; i < ruleParams.length; i++) {            if (ruleParams[i].key == keccak256("lens.param,graph")) {                graphToCheck = abi.decode(ruleParams[i].value, (address));            } else if (ruleParams[i].key == keccak256("lens.param,minFollowers")) {                minFollowers = abi.decode(ruleParams[i].value, (uint256));            }        }        // Aims to check if the graph is a valid Graph contract        IGraph(graph).getFollowersCount(address(this));        _graphToCheck[msg.sender][configSalt] = graphToCheck;        _minFollowers[msg.sender][configSalt] = minFollowers;    }}
```

As you can see, we treated the minimum followers parameter as optional, setting a default value of 100 followers for it in case that the parameter was not found in the ruleParams. On the other hand, the graph parameter is treated as required, without default value, and needing to be found as a valid graph address in order for the getFollowersCount call to not revert.

2

### Implement the Process Joining function

Next, implement the processJoining function. This function is invoked by the Group contract every time someone tries to join the Group, so then our custom logic can be applied to shape under which conditions the operation can succeed.

The function receives the configuration salt (configSalt), so we know which configuration to use, the account attempting to join the Group (account), an array of key-value pairs with the custom parameters passed to the Group (primitiveParams), and an array of key-value pairs in case the rule requires additional parameters to work (ruleParams).

The function must revert in case of not meeting the requirements imposed by the rule.

We first get the configured Graph where to perform the check:

```
contract FollowerCountGatedGroupRule is IGroupRule {    mapping(address group => mapping(bytes32 configSalt => address graph)) internal _graphToCheck;    mapping(address group => mapping(bytes32 configSalt => uint256 minFollowers)) internal _minFollowers;
    // . . .
    function processJoining(        bytes32 configSalt,        address account,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        // We get the Graph where to check the followers count        IGraph graph = IGraph(_graphToCheck[msg.sender][configSalt]);    }}
```

Next we require that account has at least the amount of followers required by the rule configuration.

The IGraph interface contains this function in order to check the amount of followers of a given account:

```
function getFollowersCount(address account) external view returns (uint256);
```

So, let's add the requirement check and we are done with this function:

```
contract FollowerCountGatedGroupRule is IGroupRule {    mapping(address group => mapping(bytes32 configSalt => address graph)) internal _graphToCheck;    mapping(address group => mapping(bytes32 configSalt => uint256 minFollowers)) internal _minFollowers;
    // . . .
    function processJoining(        bytes32 configSalt,        address account,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        IGraph graph = IGraph(_graphToCheck[msg.sender][configSalt]);        // We check if the account has the min required amount of followers        require(graph.getFollowersCount(account) >= _minFollowers[msg.sender][configSalt]);    }}
```

3

### Implement the Process Leaving function

Next, implement the processLeaving function. This function is invoked by the Group contract every time someone tries to leave the Group, so then our custom logic can be applied to shape under which conditions the operation can succeed.

The parameters are the same as in the processJoining function except that the account is trying to leave the Group instead of joining it.

Given that we do not want to apply any restriction to the leaving operation, we can just revert the function with a NotImplemented error, which is the safest approach in case someone accidentally applies this rule:

```
contract FollowerCountGatedGroupRule is IGroupRule {
    // . . .
    function processLeaving(        bytes32 configSalt,        address account,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        revert Errors.NotImplemented();    }}
```

4

### Implement the Process Removal function

Next, implement the processRemoval function. This function is invoked by the Group contract every time a Group member is trying to be removed, so then our rule can define if this operation must succeed or not.

The function receives the configuration salt (configSalt), so we know which configuration to use, the address that is trying to remove the member (originalMsgSender), the account trying to be removed of the Group (account), an array of key-value pairs with the custom parameters passed to the Group (primitiveParams), and an array of key-value pairs in case the rule requires additional parameters to work (ruleParams).

The function must revert in case of not meeting the requirements imposed by the rule. In this case, we do not want to impose any restriction on the removal operation. As a good practice, we revert for unimplemented rule functions, as it is safer in case the rule becomes accidentally applied.

```
contract FollowerCountGatedGroupRule is IGroupRule {
    // . . .
    function processRemoval(        bytes32 configSalt,        address originalMsgSender,        address account,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        revert Errors.NotImplemented();    }}
```

5

### Implement the Process Addition function

Finally, implement the processAddition function. This function is invoked by the Group contract every time a Group member is trying to be added, so then our rule can define if this operation must succeed or not.

The parameters are the same as in the processRemoval function except that the account is trying to be added to the Group instead of removed from it.

Same as in the processRemoval, here in the processAddition we do not want to impose any restriction, so we revert the function with a NotImplemented error:

```
contract FollowerCountGatedGroupRule is IGroupRule {
    // . . .
    function processAddition(        bytes32 configSalt,        address originalMsgSender,        address account,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        revert Errors.NotImplemented();    }}
```

Now the FollowerCountGatedGroupRule is ready to be applied into any Group. See the full code below:

```
contract FollowerCountGatedGroupRule is IGroupRule {    mapping(address group => mapping(bytes32 configSalt => address graph)) internal _graphToCheck;    mapping(address group => mapping(bytes32 configSalt => uint256 minFollowers)) internal _minFollowers;
    function configure(bytes32 configSalt, KeyValue[] calldata ruleParams) external override {        address graphToCheck;        uint256 minFollowers = 100;        for (uint256 i = 0; i < ruleParams.length; i++) {            if (ruleParams[i].key == keccak256("lens.param,graph")) {                graphToCheck = abi.decode(ruleParams[i].value, (address));            } else if (ruleParams[i].key == keccak256("lens.param,minFollowers")) {                minFollowers = abi.decode(ruleParams[i].value, (uint256));            }        }        // Aims to check if the graph is a valid Graph contract        IGraph(graph).getFollowersCount(address(this));        _graphToCheck[msg.sender][configSalt] = graphToCheck;        _minFollowers[msg.sender][configSalt] = minFollowers;    }
    function processAddition(        bytes32 configSalt,        address originalMsgSender,        address account,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        revert Errors.NotImplemented();    }
    function processRemoval(        bytes32 configSalt,        address originalMsgSender,        address account,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        revert Errors.NotImplemented();    }
    function processJoining(        bytes32 configSalt,        address account,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        // We get the Graph where to check the followers count        IGraph graph = IGraph(_graphToCheck[msg.sender][configSalt]);        // We check if the account has the min required amount of followers        require(graph.getFollowersCount(account) >= _minFollowers[msg.sender][configSalt]);    }
    function processLeaving(        bytes32 configSalt,        address account,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        revert Errors.NotImplemented();    }}
```

Stay tuned for API integration of rules and more guides!

[Previous\\
\\
**Manage Groups**](https://lens.xyz/docs/protocol/groups/manage) [Next\\
\\
**Banned Accounts**](https://lens.xyz/docs/protocol/groups/banned-accounts)

## Assigning Usernames Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Assigning Usernames

This guide explains how to assign and unassign a username to an Account on Lens.

## Assign a Username

To assign a Username to the logged-in Account, follow these steps.

You MUST be authenticated as Account Owner or Account Manager of the Account
you want to assign a Username to.

1

### Fetch Owned Usernames

First, list all usernames owned by the logged-in Account.

- TypeScript
- GraphQL
- React

Use the paginated fetchUsernames action to fetch the list of usernames owned by the logged-in Account address.

```
import { evmAddress } from "@lens-protocol/client";import { fetchUsernames } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await fetchUsernames(sessionClient, {  filter: { owned: evmAddress("0x1234…") },});
if (result.isErr()) {  return console.error(result.error);}
// items: Array<Username>const { items, pageInfo } = result.value;
```

See the [Pagination](https://lens.xyz/docs/protocol/best-practices/pagination) guide for more information on how to handle paginated results.

2

### Check Rules

Next, inspect the username.operations.canAssign field of the desired Username to determine whether the logged-in Account is allowed to assign the given Username. Some username namespaces may have restrictions on who can assign a Username.

```
switch (username.operations.canAssign.__typename) {  case "NamespaceOperationValidationPassed":    // Assignment is allowed    break;
  case "NamespaceOperationValidationFailed":    // Assignment is not allowed    console.log(username.operations.canAssign.reason);    break;
  case "NamespaceOperationValidationUnknown":    // Validation outcome is unknown    break;}
```

Where:

- NamespaceOperationValidationPassed: The logged-in Account is allowed to assign the given Username.

- NamespaceOperationValidationFailed: Assignment is not allowed. The reason field explains why, and unsatisfiedRules lists the unmet requirements.

- NamespaceOperationValidationUnknown: The Namespace has one or more _unknown rules_ requiring ad-hoc verification. The extraChecksRequired field provides the addresses and configurations of these rules.


Treat the NamespaceOperationValidationUnknown as _failed_ unless you intend
to support the specific rules. See [Namespace Rules](https://lens.xyz/docs/protocol/usernames/rules) for more
information.

3

### Assign the Username

Next, if allowed, assign the desired Username to the Account.

- TypeScript
- GraphQL
- React

Use the assignUsernameToAccount action to assign a Username.

```
import { assignUsernameToAccount } from "@lens-protocol/client/actions";
const result = await assignUsernameToAccount(sessionClient, {  username: {    localName: "wagmi",  },});
```

4

### Handle Result

- TypeScript
- GraphQL
- React

Finally, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await assignUsernameToAccount(sessionClient, {  username: {    localName: "wagmi",  },}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Unassign a Username

To unassign a Username from the logged-in Account, follow these steps.

You MUST be authenticated as Account Owner or Account Manager of the Account
that owns the Username you want to unassign.

1

### Check Rules

First, inspect the username.operations.canUnassign field of the desired Username to determine whether the logged-in Account is allowed to unassign the given Username. Some username namespaces may have restrictions on who can unassign a Username.

```
switch (username.operations.canUnassign.__typename) {  case "NamespaceOperationValidationPassed":    // Unassignment is allowed    break;
  case "NamespaceOperationValidationFailed":    // Unassignment is not allowed    console.log(username.operations.canUnassign.reason);    break;
  case "NamespaceOperationValidationUnknown":    // Validation outcome is unknown    break;}
```

Where:

- NamespaceOperationValidationPassed: The logged-in Account is allowed to unassign the given Username.

- NamespaceOperationValidationFailed: Unassignment is not allowed. The reason field explains why, and unsatisfiedRules lists the unmet requirements.

- NamespaceOperationValidationUnknown: The Namespace has one or more _unknown rules_ requiring ad-hoc verification. The extraChecksRequired field provides the addresses and configurations of these rules.


Treat the NamespaceOperationValidationUnknown as _failed_ unless you intend
to support the specific rules. See [Namespace Rules](https://lens.xyz/docs/protocol/usernames/rules) for more
information.

2

### Unassign Current Username

Next, if allowed, unassign the Username.

- TypeScript
- GraphQL
- React

Use the unassignUsernameFromAccount to unassign a Username.

```
import { unassignUsernameFromAccount } from "@lens-protocol/client/actions";
const result = await unassignUsernameFromAccount(sessionClient);
```

3

### Handle Result

- TypeScript
- GraphQL
- React

Finally, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await unassignUsernameFromAccount(sessionClient).andThen(  handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

[Previous\\
\\
**Fetch Usernames**](https://lens.xyz/docs/protocol/usernames/fetch) [Next\\
\\
**Custom Namespaces**](https://lens.xyz/docs/protocol/usernames/custom-namespaces)

## Rules in Lens Protocol
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

IfUserholds1 NFTJoin GroupIfUserisApprovedAble to ConnectPay1 GHOtoPostPay to Post

# Rules

Rules are modular smart contracts that define custom logic and constraints across various elements like Graphs, Feeds, Usernames, and Groups within Lens.
They enable developers to enforce specific conditions—for example, restricting access to a feed to users who own a particular NFT or token.
This modularity allows for a high degree of customization without altering the core protocol, facilitating innovative use cases and tailored experiences within the network.

By applying rules, developers and administrators can control interactions and access, ensuring that their platforms operate according to their desired parameters.
Whether it's gating content, managing membership criteria, or setting transactional conditions, rules provide the flexibility to implement complex logic in a
straightforward and maintainable way.

Rules can be applied to Groups, Feeds, Graphs, and Usernames, allowing for a wide range of use cases and configurations.

[Previous\\
\\
**Graph**](https://lens.xyz/docs/protocol/concepts/graph) [Next\\
\\
**Actions**](https://lens.xyz/docs/protocol/concepts/actions)

## Lens Username Rules
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Page not found.

Sorry. The page you're looking for can't be found.

Back to home

## Sponsorship Overview
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

Sponsor Gas

# Sponsorship

Sponsorships on Lens allow apps or entities to cover gas fees on behalf of users, enhancing accessibility and user experience.
Leveraging the concept of Paymasters from native account abstraction, sponsors deploy paymaster contracts that can sponsor transactions for users,
enabling them to pay transaction fees. This innovative approach eliminates the friction associated
with transaction costs, particularly for new users unfamiliar with blockchain mechanics.

Sponsors can set rate limits, access control lists, and exclusion lists to manage how and when users benefit from sponsored transactions.
This includes defining daily or monthly limits and requiring backend validation for added security.
Sponsorships are linked to specific apps and gives the apps full control of who they sponsor.
Administrators have full control over sponsorship settings, including pausing or unpausing the service and adding metadata to describe the sponsorship.
By significantly enhancing user experience, sponsorships pave the way for broader adoption of blockchain technology within the Lens ecosystem.

[Previous\\
\\
**Actions**](https://lens.xyz/docs/protocol/concepts/actions) [Next\\
\\
**Getting Started**](https://lens.xyz/docs/protocol/getting-started/typescript)

## Sponsoring Transactions Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Sponsoring Transactions

Lens allows apps to offer a **free** user experience to their end-users through Sponsorships.

Lens Sponsorship enables developers to provide a fully configurable, gasless experience for their users. It leverages the [ZKsync Paymaster](https://docs.zksync.io/build/start-coding/quick-start/paymasters-introduction).

After creating and funding a Sponsorship, it can be used to cover gas fees for Lens Protocol transactions, as well as any other transactions on the Lens Chain.

## Create Sponsorship

To create a Sponsorship, follow these steps.

You MUST be authenticated as a [Builder](https://lens.xyz/docs/protocol/authentication) to create a
Sponsorship.

1

### Create Metadata

First, create the Sponsorship Metadata object.

- TS/JS
- JSON Schema

Use the @lens-protocol/metadata package to construct a valid SponsorshipMetadata object:

```
import { sponsorship } from "@lens-protocol/metadata";
const metadata = sponsorship({  name: "GasPal",});
```

2

### Upload Metadata

Next, upload the Sponsorship Metadata object to a public URI.

```
import { storageClient } from "./storage-client";
const { uri } = await storageClient.uploadAsJson(metadata);
console.log(uri); // e.g., lens://4f91ca…
```

This example uses [Grove storage](https://lens.xyz/docs/protocol/storage) to host the Metadata object. See
the [Lens Metadata\\
Standards](https://lens.xyz/docs/protocol/best-practices/metadata-standards#host-metadata-objects) guide
for more information on hosting Metadata objects.

3

### Deploy Contract

Next, deploy the Lens Sponsorship smart contract.

By setting the allowLensAccess flag to true, you are allowing the Lens API
to use the Sponsorship to sponsor Lens transactions for users of your Lens
App.

- TypeScript
- GraphQL

Use the createSponsorship action to deploy the Lens Sponsorship smart contract.

```
import { uri } from "@lens-protocol/client";import { createSponsorship } from "@lens-protocol/client/actions";
// …
const result = await createSponsorship(sessionClient, {  metadataUri: uri("lens://4f91…"), // the URI from the previous step  allowLensAccess: true,});
```

4

### Handle Result

- TypeScript
- GraphQL

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await createSponsorship(sessionClient, {  metadataUri: uri("lens://4f91…"), // the URI from the previous step  allowLensAccess: true,}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Fund Sponsorship

To sponsor transactions for your users, you must periodically fund your Lens Sponsorship.

This involves sending native GHO ( _GRASS_ on Testnet) to the Lens Sponsorship contract address.

You can accomplish this either manually through a wallet or programmatically using code.

```
import { ethers } from "ethers";
import { wallet } from "./wallet";
const response = await wallet.sendTransaction({  to: "<SPONSORSHIP_ADDRESS>",  value: ethers.parseEther("100"), // Amount in native tokens});
const receipt = await response.wait();
// funded
```

Refer to the Lens Chain [integration guide](https://lens.xyz/docs/chain/integrations/viem) for
more options on how to integrate with the Lens Chain.

## Sponsor Lens Transactions

To start using Lens Sponsorship to sponsor Lens transactions for your users, follow these steps.

To simplify the development process on Testnet, if an app Sponsorship contract
is not configured, **all transactions** are sponsored by Lens through a global
Sponsorship contract.

1

### Set App Sponsorship

First, configure your Lens [App](https://lens.xyz/docs/protocol/apps/index.mdx) to use a Sponsorship you previously created.

- TypeScript
- GraphQL

Use the setAppSponsorship action to set the Sponsorship for your App.

```
import { evmAddress } from "@lens-protocol/client";import { setAppSponsorship } from "@lens-protocol/client/actions";
// …
const result = await setAppSponsorship(sessionClient, {  app: evmAddress("0x1234…"),  sponsorship: evmAddress("0x5678…"),});
```

2

### Handle Result

- TypeScript
- GraphQL

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await setAppSponsorship(sessionClient, {  app: evmAddress("0x1234…"),  sponsorship: evmAddress("0x5678…"),}).andThen(handleOperationWith(walletClient));
```

And, ensure the transaction was successful:

```
const result = await setAppSponsorship(sessionClient, {  app: evmAddress("0x1234…"),  sponsorship: evmAddress("0x5678…"),})  .andThen(handleOperationWith(signer))  .andThen(sessionClient.waitForTransaction);
if (result.isErr()) {  return console.error(result.error);}
// The transaction was successful
```

3

### Authentication Workflow

Finally, implement the [Authentication Workflow](https://lens.xyz/docs/protocol/apps/authorization-workflows#implementation) to be able to authorize end-users for your sponsorship. If this is not implemented, the Lens API will require end-users to cover transaction fees by returning a [Self-Funded Transaction Request](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle#tiered-transaction-model-social-operations-self-funded-transaction-request-fallback) for any operation involving a transaction.

Since transactions on Testnet fall back to being sponsored by the Lens global
Sponsorship if no app Sponsorship is configured, you might not notice any
visible difference in the final user experience until deploying to Mainnet,
where the full behavior is enforced.

## Sponsor Any Transaction

To sponsor any transaction on the Lens Chain using funds from your Sponsorship, follow these steps.

1

### Sponsorship Signer

First, generate a new private key for the address responsible for approving sponsorship requests (i.e., the signer).

```
cast wallet new
Successfully created new keypair.Address:     0x8711d4d6B7536D…Private key: 0x72433488d76ffec7a16b…
```

2

### Add Signer

Next, add the signer to your Sponsorship.

You MUST be authenticated as a [Builder](https://lens.xyz/docs/protocol/authentication) and be the owner
or an admin for the Sponsorship you want to add the signer to.

- TypeScript
- GraphQL

Use the updateSponsorshipSigners action to add the signer to your Sponsorship.

```
import { evmAddress } from "@lens-protocol/client";import { updateSponsorshipSigners } from "@lens-protocol/client/actions";
// …
const result = await updateSponsorshipSigners(sessionClient, {  sponsorship: evmAddress("0xe2f2a5C287993345a840db3B0845fbc70f5935a5"),  toAdd: [    {      address: evmAddress("0x8711d4d6B7536D…"),      label: "My Backend System",    },  ],});
```

3

### Handle Result

- TypeScript
- GraphQL

Then, handle the result using the adapter for the library of your choice. Ensure the transaction is successful:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await updateSponsorshipSigners(sessionClient, {  sponsorship: evmAddress("0xe2f2a5C287993345a840db3B0845fbc70f5935a5"),  toAdd: [    {      address: evmAddress("0x8711d4d6B7536D…"),      label: "My Backend System",    },  ],})  .andThen(handleOperationWith(walletClient))  .andThen(sessionClient.waitForTransaction);
```

4

### Sponsorship Logic

Finally, implement the logic to sponsor user's transaction that supports your use case.

- viem
- ethers

Here’s an example of a client-side application that sends a request to its backend to generate a sponsored transaction based on specific criteria.

```
import { parseEip712Transaction, sendEip712Transaction } from "viem/zksync";
import { wallet } from "./wallet";
const request = {  from: wallet.account.address,  to: "0x567890abcdef1234567890abcdef1234567890ab",  value: 100,};
const response = await fetch("http://localhost:3000/sponsor", {  method: "POST",  headers: {    "Content-Type": "application/json",  },  body: JSON.stringify(request),});const { serialized } = await response.json();
// send the transactionconst transaction = parseEip712Transaction(serialized) as any;const hash = await sendEip712Transaction(wallet, transaction);
```

The backend server listens for incoming requests, utilizes the SponsorshipApprovalSigner to approve the transaction, and sends the approved transaction back to the client.

```
import express from "express";import type { Address } from "viem";import { serializeTransaction } from "viem/zksync";
import { approver } from "./approver";
const app = express();app.use(express.json());
app.post("/sponsor", async (req, res) => {  try {    const approved = await approver.approveSponsorship({      account: req.body.from as Address,      to: req.body.to as Address,      value: BigInt(req.body.value),    });    res.json({      serialized: serializeTransaction(approved),    });  } catch (err) {    console.error(err);    res.status(500).json({ error: String(err) });  }});
app.listen(3000, () => {  console.log("Server listening on http://localhost:3000");});
```

[Previous\\
\\
**Membership Approvals**](https://lens.xyz/docs/protocol/groups/membership-approvals) [Next\\
\\
**Managing Sponsorships**](https://lens.xyz/docs/protocol/sponsorships/managing)

## Feed Rules Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Feed Rules

This guide explains how to use Feed Rules and how to implement custom ones.

Feed Rules allow administrators to add requirements or constraints when creating content on a Feed.

## Using Feed Rules

Lens provides four built-in Feed rules:

- SimplePaymentFeedRule \- Requires an ERC-20 payment to post on the Feed.

- TokenGatedFeedRule \- Requires an account to hold a certain token to post on the Feed.

- GroupGatedFeedRule \- Requires an account to be a member of a certain Group to post on the Feed.


For the SimplePaymentFeedRule, a **1.5%** Lens treasury fee is deducted from
the payment before the remaining amount is transferred to the designated
recipient.

It is also possible to use custom Feed Rules to extend the functionality of your Feed.

### Create a Feed with Rules

As part of creating [Custom Feeds](https://lens.xyz/docs/protocol/feeds/custom-feeds), you can pass a rules object that defines the required rules and/or an anyOf set, where satisfying any one rule allows posting on the Feed. These rules can be built-in or custom.

This section presumes you are familiar with the process of [creating a\\
Feed](https://lens.xyz/docs/protocol/feeds/custom-feeds) on Lens.

- TypeScript
- GraphQL
- React

```
import { bigDecimal, evmAddress, uri } from "@lens-protocol/client";import { createFeed } from "@lens-protocol/client/action";
const result = await createFeed(sessionClient, {  metadataUri: uri("lens://4f91ca…"),  rules: {    required: [      {        simplePaymentRule: {          cost: {            currency: evmAddress("0x5678…"),            value: bigDecimal("10.42"),          },          recipient: evmAddress("0x9012…"),        },      },    ],  },});
```

### Update a Feed Rules

More details on this coming soon.

## Building a Feed Rule

Let's illustrate the process with an example. We will build the GroupGatedFeedRule described above, a rule that requires accounts to be a member of a certain Group in order to Create a Post on the Feed.

To build a custom Feed Rule, you must implement the following IFeedRule interface:

```
interface IFeedRule {    function configure(bytes32 configSalt, KeyValue[] calldata ruleParams) external;
    function processCreatePost(        bytes32 configSalt,        uint256 postId,        CreatePostParams calldata postParams,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external;
    function processEditPost(        bytes32 configSalt,        uint256 postId,        EditPostParams calldata postParams,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external;
    function processDeletePost(        bytes32 configSalt,        uint256 postId,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external;
    function processPostRuleChanges(        bytes32 configSalt,        uint256 postId,        RuleChange[] calldata ruleChanges,        KeyValue[] calldata ruleParams    ) external;}
```

Each function of this interface must assume to be invoked by the Feed
contract. In other words, assume the msg.sender will be the Feed contract.

A Lens dependency package with all relevant interfaces will be available soon.

1

### Implement the Configure Function

First, implement the configure function. This function has the purpose of initializing any required state for the rule to work properly.

It receives two parameters, a 32-byte configuration salt (configSalt), and an array of custom parameters as key-value pairs (ruleParams).

The configSalt is there to allow the same rule contract to be used many times, with different configurations, for the same Feed. So, for a given Feed Rule implementation, the pair (Feed Address, Configuration Salt) should identify a rule configuration.

For example, we could want to achieve the restriction "To post on this Feed, you must be a member of Group A or Group B". In that case, instead of writing a whole new contract that receives two groups instead of one, we would just configure the GroupGatedFeedRule rule twice in the same Feed, once for Group A with some configuration salt, and once for Group B with another configuration salt.

The configure function can be called multiple times by the same Feed passing the same configuration salt in
order to update that rule configuration (i.e. reconfigure it).

The ruleParams is an array of key-value pairs that can be used to pass any custom configuration parameters to the rule. Each key is bytes32, we put the hash of the parameter name there, and each value is bytes, we set the ABI-encoded parameter value there. Given that ruleParams is an array, this allows the rule to define which parameters are optional and which are required, acting accordingly when any of them are not present.

In our example, we need to decode an address parameter, which will represent the Group contract where the account trying to post must belong to. Let's define a storage mapping to store this configuration:

```
contract GroupGatedFeedRule is IFeedRule {    mapping(address feed => mapping(bytes32 configSalt => address group)) internal _groupGate;}
```

The configuration is stored in the mapping using the Feed contract address and the configuration salt as keys. With this setup, the same rule can be used by different Feeds, as well as be used by the same Feed many times.

Now let's code the configure function itself, decoding the required address parameter and storing it in the mapping:

```
contract GroupGatedFeedRule is IFeedRule {    mapping(address feed => mapping(bytes32 configSalt => address group)) internal _groupGate;
    function configure(bytes32 configSalt, KeyValue[] calldata ruleParams) external override {        address group = address(0);        for (uint256 i = 0; i < ruleParams.length; i++) {            if (ruleParams[i].key == keccak256("lens.param.group")) {                group = abi.decode(ruleParams[i].value, (address));                break;            }        }        // Aims to check if the passed group contract is valid        IGroup(group).isMember(address(this));        _groupGate[msg.sender][configSalt] = group;    }}
```

2

### Implement the Process Create Post function

Next, implement the processCreatePost function. This function is invoked by the Feed contract every time a Post is trying to be created, so then our custom logic can be applied to shape under which conditions this operation can succeed.

The function receives the configuration salt (configSalt), so we know which configuration to use, the ID the Feed assigned to the Post (postId), the parameters of the Post (postParams, including things like author and contentURI), an array of key-value pairs with the custom parameters passed to the Feed (primitiveParams), and an array of key-value pairs in case the rule requires additional parameters to work (ruleParams).

The function must revert in case of not meeting the requirements imposed by the rule.

Groups follow the IGroup interface, which has the following function to query if an account is a member of the group or not:

```
function isMember(address account) external view returns (bool);
```

Now let's code the processCreatePost function taking all the described above into account:

```
contract GroupGatedFeedRule is IFeedRule {    mapping(address feed => mapping(bytes32 configSalt => address group)) internal _groupGate;
    // . . .
    function processCreatePost(        bytes32 configSalt,        uint256 postId,        CreatePostParams calldata postParams,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        require(IGroup(_groupGate[msg.sender][configSalt]).isMember(postParams.author));    }
```

3

### Implement the Process Edit Post function

Next, implement the processEditPost function. This function is invoked by the Feed contract every time a Post is trying to be edited, so then our custom logic can be applied to shape under which conditions this operation can succeed.

The function receives the configuration salt (configSalt), so we know which configuration to use, the ID the Feed assigned to the Post (postId), the parameters of the Post to edit (postParams), an array of key-value pairs with the custom parameters passed to the Feed (primitiveParams), and an array of key-value pairs in case the rule requires additional parameters to work (ruleParams).

The function must revert in case of not meeting the requirements imposed by the rule. In this case, given that to reach the point of editing a post, the post must have been created before, we can assume that the author of the post met the conditions to create it, and do not impose any restriction on the edit operation. As a good practice, we revert for unimplemented rule functions, as it is safer in case the rule becomes accidentally applied.

```
contract GroupGatedFeedRule is IFeedRule {
    // . . .
    function processEditPost(        bytes32 configSalt,        uint256 postId,        EditPostParams calldata postParams,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        revert Errors.NotImplemented();    }
```

4

### Implement the Process Delete Post function

Next, implement the processDeletePost function. This function is invoked by the Feed contract every time a Post is trying to be deleted, so then our custom logic can be applied to shape under which conditions this operation can succeed.

The function receives the configuration salt (configSalt), so we know which configuration to use, the ID the Feed assigned to the Post (postId), an array of key-value pairs with the custom parameters passed to the Feed (primitiveParams), and an array of key-value pairs in case the rule requires additional parameters to work (ruleParams).

The function must revert in case of not meeting the requirements imposed by the rule. In this case, given that to reach the point of deleting a post, the post must have been created before, we can assume that the author of the post met the conditions to create it, and do not impose any restriction on the delete operation. As a good practice, we revert for unimplemented rule functions, as it is safer in case the rule becomes accidentally applied.

```
contract GroupGatedFeedRule is IFeedRule {
    // . . .
    function processDeletePost(        bytes32 configSalt,        uint256 postId,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        revert Errors.NotImplemented();    }
```

5

### Implement the Process Post Rule Changes function

Finally, implement the processPostRuleChanges function. This function is invoked by the Feed contract every time an account makes a change on the [Post Rules](https://lens.xyz/docs/protocol/feeds/post-rules) of a Post it authors, so then our Feed rule can define if this change must be accepted or not.

The function receives the configuration salt (configSalt), so we know which configuration to use, the ID the Feed assigned to the Post which rules are being changed (postId), the array of rules changes (ruleChanges), and an array of key-value pairs in case the rule requires additional parameters to work (ruleParams).

The function must revert in case of not meeting the requirements imposed by the rule. In this case, the rule is not focused on controlling Post Rules changes, so we revert as a good practice to avoid unintended effects on if the rule gets applied accidentally.

```
contract GroupGatedFeedRule is IFeedRule {
    // . . .
    function processPostRuleChanges(        bytes32 configSalt,        uint256 postId,        RuleChange[] calldata ruleChanges,        KeyValue[] calldata ruleParams    ) external override {        revert Errors.NotImplemented();    }}
```

Now the GroupGatedFeedRule is ready to be applied into any Feed. See the full code below:

```
contract GroupGatedFeedRule is IFeedRule {    mapping(address feed => mapping(bytes32 configSalt => address group)) internal _groupGate;
    function configure(bytes32 configSalt, KeyValue[] calldata ruleParams) external override {        address group = address(0);        for (uint256 i = 0; i < ruleParams.length; i++) {            if (ruleParams[i].key == keccak256("lens.param.group")) {                group = abi.decode(ruleParams[i].value, (address));                break;            }        }        // Aims to check if the passed group contract is valid        IGroup(group).isMember(address(this));        _groupGate[msg.sender][configSalt] = group;    }
    function processCreatePost(        bytes32 configSalt,        uint256 postId,        CreatePostParams calldata postParams,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        require(IGroup(_groupGate[msg.sender][configSalt]).isMember(postParams.author));    }
    function processEditPost(        bytes32 configSalt,        uint256 postId,        EditPostParams calldata postParams,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        revert Errors.NotImplemented();    }
    function processDeletePost(        bytes32 configSalt,        uint256 postId,        KeyValue[] calldata primitiveParams,        KeyValue[] calldata ruleParams    ) external override {        revert Errors.NotImplemented();    }
    function processPostRuleChanges(        bytes32 configSalt,        uint256 postId,        RuleChange[] calldata ruleChanges,        KeyValue[] calldata ruleParams    ) external override {        revert Errors.NotImplemented();    }}
```

Stay tuned for API integration of rules and more guides!

[Previous\\
\\
**Custom Feeds**](https://lens.xyz/docs/protocol/feeds/custom-feeds) [Next\\
\\
**Graphs**](https://lens.xyz/docs/protocol/graphs/follow-unfollow)

## Manage Lens Apps
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Manage Apps

This guide explains how to manage Apps on Lens.

## Update App Metadata

To update the metadata of an existing app, follow these steps.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) and be owner or
admin of the App to update its metadata.

1

### Create New App Metadata

First, construct an App Metadata object with the new content.

- TS/JS
- JSON Schema

Use the @lens-protocol/metadata package to construct a valid AppMetadata object:

```
import { MetadataAttributeType, app } from "@lens-protocol/metadata";
const metadata = app({  name: "XYZ",  tagline: "The next big thing",  description: "An app to rule them all",  logo: "lens://4f91cab87ab5e4f5066f878b72…",  developer: "John Doe <john.doe@email.com>",  url: "https://example.com",  termsOfService: "https://example.com/terms",  privacyPolicy: "https://example.com/privacy",  platforms: ["web", "ios", "android"],});
```

2

### Upload App Metadata

Next, upload the App Metadata object to a public URI.

```
import { storageClient } from "./storage-client";
const { uri } = await storageClient.uploadAsJson(metadata);
console.log(uri); // e.g., lens://4f91ca…
```

This example uses [Grove storage](https://lens.xyz/docs/storage) to host the Metadata object.
See the [Lens Metadata\\
Standards](https://lens.xyz/docs/protocol/best-practices/metadata-standards#host-metadata-objects) guide
for more information on hosting Metadata objects.

3

### Update New Custom App Metadata

- TypeScript
- GraphQL

Next, update the app metadata using setAppMetadata action.

```
import { uri, evmAddress } from "@lens-protocol/client";import { setAppMetadata } from "@lens-protocol/client/actions";
// …
const result = await setAppMetadata(sessionClient, {  metadataUri: uri("lens://4f91…"), // the URI with new metadata  app: evmAddress("0x1234…"),});
```

4

### Handle Result

- TypeScript
- GraphQL

Finally, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await setAppMetadata(sessionClient, {  metadataUri: uri("lens://4f91…"),  app: evmAddress("0x1234…"),}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Update App Feeds

To update the custom feeds of an existing app, follow these steps.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) and be owner or
admin of the App to update its feeds.

1

### Update the App Feeds

- TypeScript
- GraphQL

First, update the custom feeds in an app using addAppFeeds or removeAppFeeds actions.

```
import { evmAddress } from "@lens-protocol/client";import { addAppFeeds } from "@lens-protocol/client/actions";
// …
const result = await addAppFeeds(sessionClient, {  feeds: [evmAddress("0x4546…")],  app: evmAddress("0x1234…"),});
```

2

### Handle Result

- TypeScript
- GraphQL

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await addAppFeeds(sessionClient, {  feeds: ['0x4567…']  app: evmAddress("0x1234…")}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Set App Default Feed

To set the default feed for an app, follow these steps.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) and be owner or
admin of the App to set its default feed.

1

### Update App Default Feed

- TypeScript
- GraphQL

First, use setDefaultAppFeed action to set the default feed of an app.

```
import { evmAddress } from "@lens-protocol/client";import { setDefaultAppFeed } from "@lens-protocol/client/actions";
// …
const result = await setDefaultAppFeed(sessionClient, {  feed: { custom: evmAddress("0x4546…") },  app: evmAddress("0x1234…"),});
```

2

### Handle Result

- TypeScript
- GraphQL

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await setDefaultAppFeed(sessionClient, {  feeds: { global: true },  app: evmAddress("0x1234…"),}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Update App Graph

To update the graph of an existing app, follow these steps.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) and be owner or
admin of the App to update its graph.

1

### Set New Custom App Graph

- TypeScript
- GraphQL

First, use setAppGraph action to update or set the graph of an existing app.

```
import { evmAddress } from "@lens-protocol/client";import { setAppGraph } from "@lens-protocol/client/actions";
// …
const result = await setAppGraph(sessionClient, {  graph: { custom: evmAddress("0x1234…") },  app: evmAddress("0x1234…"),});
```

2

### Handle Result

- TypeScript
- GraphQL

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await setAppGraph(sessionClient, {  graph: { globalGraph: true },  app: evmAddress("0x1234…"),}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## App Treasury

To update the treasury of an existing app, follow these steps.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) and be owner or
admin of the App to update its treasury.

1

### Update App Treasury

- TypeScript
- GraphQL

First, use setAppTreasury action to update or set the treasury of an existing app.

```
import { evmAddress } from "@lens-protocol/client";import { setAppTreasury } from "@lens-protocol/client/actions";
// …
const result = await setAppTreasury(sessionClient, {  treasury: evmAddress('0x4567…')  app: evmAddress('0x1234…')});
```

2

### Handle Result

- TypeScript
- GraphQL

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await setAppTreasury(sessionClient, {  treasury: evmAddress("0x4567…"),  app: evmAddress("0x1234…"),}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## App Sponsorship

To update the sponsorship of an existing app, follow these steps.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) and be owner or
admin of the App to update its sponsorship.

1

### Update App Sponsorship

- TypeScript
- GraphQL

First, use setAppSponsorship action to update or set the sponsorship of an existing app.

```
import { evmAddress } from "@lens-protocol/client";import { setAppSponsorship } from "@lens-protocol/client/actions";
// …
const result = await setAppSponsorship(sessionClient, {  app: evmAddress("0x1234…"),  sponsorship: evmAddress("0x4567…"),});
```

2

### Handle Result

- TypeScript
- GraphQL

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await setAppSponsorship(sessionClient, {  sponsorship: evmAddress("0x4567…"),  app: evmAddress("0x1234…"),}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Access Control

The App contract supports two roles: _Owner_ and _Administrator_.

Administrators can:

- Update the App Metadata

- Update the App Rules

- Update the App Feeds and Graph

- Update the App Treasury

- Update the App Sponsorship


The Owner can do everything the administrators can do, plus transfer ownership of the App to another address.

See the [Team Management](https://lens.xyz/docs/protocol/best-practices/team-management) guide for more information on how to manage these roles.

[Previous\\
\\
**Fetch Apps**](https://lens.xyz/docs/protocol/apps/fetch) [Next\\
\\
**Authorization Workflows**](https://lens.xyz/docs/protocol/apps/authorization-workflows)

## Lens Account Overview
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Account

An Account for Lens is a smart contract designed to support flexible ownership and programmable interactions.
Each Account enables collaborative management by allowing the primary owner to assign permissions to additional account managers.
These managers can perform actions on behalf of the account—such as posting content, following others, or setting metadata—without compromising the owner’s
authority to transfer ownership or revoke permissions.

This structure provides flexibility for groups or organizations to control a single account collaboratively alongside.
Accounts can also enforce custom controls, like blocking or unblocking users, and support features such as custom signature schemes, multi-sig capabilities, and spending limits.
This level of programmability opens new possibilities for personalized and secure interactions within the Lens ecosystem, adapting to various use cases.

[Previous\\
\\
**Overview**](https://lens.xyz/docs/protocol) [Next\\
\\
**App**](https://lens.xyz/docs/protocol/concepts/app)

## Team Management Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Team Management

This guide explains how to manage your team's access to your Lens primitives.

Lens uses a unified approach to access control for its primitives (apps, graphs, feeds, etc.). There are two types of roles:

- **Owner**: The owner has full control over a primitive, including adding and removing admins and transferring ownership. The initial owner is the address that creates the primitive.

- **Admin**: An admin can perform most actions except transferring ownership. See the individual primitive documentation for more details.


This document identifies as primitives the following Lens entities:

- [Apps](https://lens.xyz/docs/protocol/apps)

- [Graphs](https://lens.xyz/docs/protocol/graphs/custom-graphs)

- [Feeds](https://lens.xyz/docs/protocol/feeds/custom-feeds)

- [Groups](https://lens.xyz/docs/protocol/groups/create)

- [Username Namespaces](https://lens.xyz/docs/protocol/usernames/custom-namespaces)

- [Sponsorships](https://lens.xyz/docs/protocol/sponsorships/sponsoring-transactions)


The steps are the same for all primitives, so we will just refer to them their primitive address.

## Add Admins

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) to make this
request.

1

### Prepare the Request

- TypeScript
- GraphQL

Use the addAdmins action to add Admins to an owned primitive.

```
import { evmAddress } from "@lens-protocol/client";import { addAdmins } from "@lens-protocol/client/actions";
const result = await addAdmins(sessionClient, {  admins: [evmAddress("0x1234…"), evmAddress("0x5678…")],  address: evmAddress("0x90ab…"), // address of the primitive (app/graph/feed/etc)});
```

2

### Handle Result

- TypeScript
- GraphQL

Finally, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await addAdmins(sessionClient, {  admins: [evmAddress("0x1234…"), evmAddress("0x5678…")],  address: evmAddress("0x3243…"),}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Remove Admins

1

### Prepare the Request

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) to make this
request.

- TypeScript
- GraphQL

Use the removeAdmins action to remove Admins from an owned primitive.

```
import { evmAddress } from "@lens-protocol/client";import { removeAdmins } from "@lens-protocol/client/actions";
const result = await removeAdmins(sessionClient, {  admins: [evmAddress("0x1234…"), evmAddress("0x5678…")],  address: evmAddress("0x90ab…"), // address of the primitive (app/graph/feed/etc)});
```

2

### Handle Result

- TypeScript
- GraphQL

Finally, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await removeAdmins(sessionClient, {  admins: [evmAddress("0x1234…"), evmAddress("0x5678…")],  address: evmAddress("0x3243…"),}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

## Fetch Admins

In some cases, you may need to fetch the list of admins for a primitive.

Since a Lens Account, by being a smart wallet, can potentially be a
primitive's admin, you can also search admins by their username.

- TypeScript
- GraphQL

Use the paginated fetchAdminsFor action to fetch a list of admins for a primitive.

```
import { evmAddress } from "@lens-protocol/client";import { fetchAdminsFor } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await fetchAdminsFor(client, {  address: evmAddress("0x1234…"),});
if (result.isErr()) {  return console.error(result.error);}
// items: Array<Admin>: [{ account: Account, addedAt: DateTime }, …]const { items, pageInfo } = result.value;
```

See the [Pagination](https://lens.xyz/docs/protocol/best-practices/pagination) guide for more information on how to handle paginated results.

## Transfer Ownership

The owner of a primitive can transfer ownership to another address.

1

### Prepare the Request

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) to make this
request.

- TypeScript
- GraphQL

Use the transferPrimitiveOwnership action to prepare the transfer of ownership of a primitive.

```
import { evmAddress } from "@lens-protocol/client";import { transferPrimitiveOwnership } from "@lens-protocol/client/actions";
const result = await transferPrimitiveOwnership(sessionClient, {  address: evmAddress("0x5678…"),  newOwner: evmAddress("0x1234…"),});
```

2

### Handle Result

- TypeScript
- GraphQL

Finally, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await transferPrimitiveOwnership(sessionClient, {  address: evmAddress("0x5678…"),  newOwner: evmAddress("0x1234…"),}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

[Previous\\
\\
**Metadata Standards**](https://lens.xyz/docs/protocol/best-practices/metadata-standards) [Next\\
\\
**Mentions**](https://lens.xyz/docs/protocol/best-practices/mentions)

## Managing Sponsorships Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Managing Sponsorships

This guide covers how to manage your Lens Sponsorship contract.

## Rate Limiting

Lens Sponsorships allow you to scale your app while protecting it from abuse. Sponsorships can be configured with app-wide as well as per-user rate limits with configurable reset windows. This gives the developer full visibility and control over the usage of their app.

```
input SponsorshipRateLimits {  """  The global rate limit.  """  global: SponsorshipRateLimit
  """  The user rate limit.  """  user: SponsorshipRateLimit}
```

### Configure Limits

You can provide rate limits when deploying the Sponsorship contract as well as update them later.

1

#### Update Limits

First, create the transaction request to update the rate limits of a Sponsorship.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) and be either the
owner or an admin of the Sponsorship you intend to configure.

- TypeScript
- GraphQL

Use the updateSponsorshipLimits action to update the rate limits of the Lens Sponsorship smart contract.

```
import { evmAddress, SponsorshipRateLimitWindow } from "@lens-protocol/client";import { updateSponsorshipLimits } from "@lens-protocol/client/actions";
// …
const result = await updateSponsorshipLimits(sessionClient, {  sponsorship: evmAddress("0xe2f2a5C287993345a840db3B0845fbc70f5935a5"),  rateLimits: {    user: {      window: SponsorshipRateLimitWindow.Hour,      limit: 100,    },    global: {      window: SponsorshipRateLimitWindow.Day,      limit: 1_000_000,    },  },});
```

2

#### Handle Result

- TypeScript
- GraphQL

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await updateSponsorshipLimits(sessionClient, {  sponsorship: evmAddress("0xe2f2a5C287993345a840db3B0845fbc70f5935a5"),  rateLimits: {    // …  },}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

### Exclusion List

To enable certain use-cases such as trusted VIP/users, the rate-limiting feature can be optionally bypassed for given addresses by adding them to an exclusion list.

#### Update Exclusion List

1

#### Prepare the Request

First, create the transaction request to update the exclusion list of a Sponsorship.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) and be either the
owner or an admin of the Sponsorship you intend to configure.

- TypeScript
- GraphQL

Use the updateSponsorshipExclusionList action to update the exclusions list of the Lens Sponsorship smart contract.

You can add and remove entries as part of the same transaction.

```
import { evmAddress, SponsorshipRateLimitWindow } from "@lens-protocol/client";import { updateSponsorshipExclusionList } from "@lens-protocol/client/actions";
// …
const result = await updateSponsorshipExclusionList(sessionClient, {  sponsorship: evmAddress("0xe2f2a5C287993345a840db3B0845fbc70f5935a5"),  toAdd: [    {      address: evmAddress("0x1234…"),      label: "Bob The Builder",    },  ],  toRemove: [evmAddress("0x5678…")],});
```

2

#### Handle Result

- TypeScript
- GraphQL

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await updateSponsorshipExclusionList(sessionClient, {  sponsorship: evmAddress("0xe2f2a5C287993345a840db3B0845fbc70f5935a5"),  toAdd: [    // …  ],  toRemove: [    // …  ],}).andThen(handleOperationWith(walletClient));
```

See the [Transaction Lifecycle](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle) guide for more information on how to determine the status of the transaction.

#### Fetch Exclusion List

- TypeScript
- GraphQL

Use the paginated fetchSponsorshipLimitExclusions action to fetch a list of addresses that are excluded from the rate limits.

```
import { evmAddress } from "@lens-protocol/client";import { fetchSponsorshipLimitExclusions } from "@lens-protocol/client/actions";
import { client } from "./client";
const posts = await fetchSponsorshipLimitExclusions(client, {  filter: {    sponsorship evmAddress("0x1234…"),  },});
if (result.isErr()) {  return console.error(result.error);}
// items: Array<{ sponsorship: EvmAddress, label: string, address: EvmAddress, createdAt: DateTimeTime }>const { items, pageInfo } = result.value;
```

See the [Pagination](https://lens.xyz/docs/protocol/best-practices/pagination) guide for more information on how to handle paginated results.

## Signers

To ensure that sponsored transactions are only used by the intended users, the Sponsorship contract uses a list of authorized signers. These signers are one or more addresses that need to supply their signature to every transaction sent to the Sponsorship contract, indicating that the transaction originates from their app.

This is the mechanism behind the allowLensAccess flag you encountered when [deploying the Sponsorship contract](https://lens.xyz/docs/protocol/sponsorships/sponsoring-transactions#create-sponsorship-deploy-contract)—it allows the Lens API to sponsor transactions for users while they are logged into your app.

### Update Signers

You can provide a list of signers when deploying the Sponsorship contract as well as update them later.

1

#### Configure Signers

First, create the transaction request to update the signers of a Sponsorship.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) and be either the
owner or an admin of the Sponsorship you intend to configure.

- TypeScript
- GraphQL

Use the updateSponsorshipSigners action to update the signers of the Lens Sponsorship smart contract.

```
import { evmAddress } from "@lens-protocol/client";import { updateSponsorshipSigners } from "@lens-protocol/client/actions";
// …
const result = await updateSponsorshipSigners(sessionClient, {  sponsorship: evmAddress("0x1234…"),  toAdd: [    {      address: evmAddress("0x5678…"),      label: "My Backend System",    },  ],});
```

2

#### Handle Result

- TypeScript
- GraphQL

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await updateSponsorshipSigners(sessionClient, {  sponsorship: evmAddress("0x1234…"),  toRemove: [evmAddress("0x5678…")],}).andThen(handleOperationWith(walletClient));
```

### Fetch Signers

- TypeScript
- GraphQL

Use the paginated fetchSponsorshipSigners action to list the signers of a Sponsorship.

```
import { evmAddress } from "@lens-protocol/client";import { fetchSponsorshipSigners } from "@lens-protocol/client/actions";
import { client } from "./client";
const result = await fetchSponsorshipSigners(client, {  filter: {    sponsorship: evmAddress("0x1234…"),  },});
if (result.isErr()) {  return console.error(result.error);}
// items: Array<SponsorshipSigner>// const { items, pageInfo } = result.value;
```

See the [Pagination](https://lens.xyz/docs/protocol/best-practices/pagination) guide for more information on how to handle paginated results.

## Pausing Sponsorships

By default, Sponsorships are active when deployed and ready to use. You can pause a Sponsorship to stop it from being used to sponsor transactions.

1

#### Prepare Transaction

First, create the transaction request to pause or unpause a Sponsorship.

You MUST be authenticated as [Builder](https://lens.xyz/docs/protocol/authentication) and be either the
owner or an admin of the Sponsorship you intend to configure.

- TypeScript
- GraphQL

Use the pauseSponsorship or unpauseSponsorship action to pause or unpause a Sponsorship.

```
import { evmAddress } from "@lens-protocol/client";import { pauseSponsorship } from "@lens-protocol/client/actions";
// …
const result = await pauseSponsorship(sessionClient, {  sponsorship: evmAddress("0x1234…"),});
```

2

#### Handle Result

- TypeScript
- GraphQL

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await pauseSponsorship(sessionClient, {  sponsorship: evmAddress("0x1234…"),}).andThen(handleOperationWith(walletClient));
```

## Access Control

The Sponsorship contract supports two roles: _Owner_ and _Administrators_.

Administrators can:

- Add and remove authorized signers

- Add and remove addresses to the rate limit exclusion list

- Update the rate limits

- Pause and unpause the Sponsorship


The Owner can do everything the administrators can do, plus:

- Transfer ownership

- Update the list of administrators

- Withdraw the funds from the Sponsorship


See the [Team Management](https://lens.xyz/docs/protocol/best-practices/team-management) guide for more information on how to manage these roles.

[Previous\\
\\
**Sponsoring Transactions**](https://lens.xyz/docs/protocol/sponsorships/sponsoring-transactions) [Next\\
\\
**Fetch Sponsorships**](https://lens.xyz/docs/protocol/sponsorships/fetch)

## Error Handling Guide
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Error Handling

This guide will show you how to handle errors on Lens.

Lens tools categorize errors as either **failures** or **exceptions**:

- **Failure**: A known issue directly related to business logic prevents the task from completing successfully. These scenarios are anticipated and managed within the application.

- **Exception**: An unexpected issue arises, such as incorrect usage, invariant errors, or external/system malfunctions, which are not tied to business logic.


- TypeScript
- GraphQL

The Lens SDK adopts a functional approach to error handling. At its core, it uses a Result<T, E> object as the return value for many of its functions. This object can represent one of two states:

- Ok<T>: A **successful** result containing a value of type T.

- Err<E>: A **failure** containing an error of type E.


Any **error thrown** should be considered an **exception**—a malfunction not contemplated by the code.

This approach avoids reliance on try/catch blocks and promotes predictable,
type-safe code by ensuring errors are handled explicitly.

Specifically, the SDK uses the [NeverThrow](https://www.npmjs.com/package/neverthrow) library, which is re-exported for convenience.

```
import { Result, Ok, Err, ok, err } from "@lens-protocol/react";
```

Let’s explore the concept with a simple example function:

```
function parseNumber(input: string): Result<number, string> {  return isNaN(Number(input)) ? err("Invalid number") : ok(Number(input));}
```

Use the convenient isOk() or isErr() methods to narrow down the result type:

```
const result = parseNumber("42");
if (result.isOk()) {  console.log("Number:", result.value);} else {  console.error("Error:", result.error);}
```

You can chain multiple operations:

```
function divide(a: number, b: number): Result<number, string> {  return b === 0 ? err("Division by zero") : ok(a / b);}
const result = parseNumber("42").andThen((num) => divide(num, 2));
if (result.isOk()) {  console.log("Result:", result.value);} else {  console.error("Error:", result.error);}
```

You can also provide a default value:

```
const value = parseNumber("invalid").unwrapOr(0); // 0
```

NeverThrow also provides a ResultAsync type for handling asynchronous operations. This is a _thenable object_ that can be awaited, and/or chained with other operations:

```
const result = await ResultAsync.fromPromise(  fetch("https://api.example.com/data"))  .map((response) => response.json())  .mapErr((error) => `Failed to fetch data: ${error}`);
if (result.isOk()) {  console.log("Data:", result.value);} else {  console.error("Error:", result.error);}
```

See the [NeverThrow documentation](https://github.com/supermacro/neverthrow) for more information.

[Previous\\
\\
**Paginated Results**](https://lens.xyz/docs/protocol/best-practices/pagination) [Next\\
\\
**Transaction Lifecycle**](https://lens.xyz/docs/protocol/best-practices/transaction-lifecycle)

## Lens Account Funds
[Build on](https://developer.lens.xyz/)

Chain

Protocol

Grove

[Help & Support](mailto:support@lens.xyz)

# Account Funds

This guide explains how to manage your Lens Account funds.

The Lens Account is a smart wallet that allows you to manage funds for your collects, tips, and other transactions on Lens. By using the Lens Account funds, your wallet's exposure to the Lens app is minimized, which helps mitigate potential security threats.

## Account Balances

A Lens Account can hold native **GHO** tokens ( **GRASS** on testnet) and various ERC-20 tokens. This section explains how to fetch the balances for the authenticated account.

You MUST be authenticated as Account Owner or Account Manager of the Lens
Account you intend to fetch balances for.

- TypeScript
- GraphQL
- React

Use the fetchAccountBalances action to fetch a finite number of balances.

```
import { evmAddress } from "@lens-protocol/client";import { fetchAccountBalances } from "@lens-protocol/client/actions";
const result = await fetchAccountBalances(sessionClient, {  tokens: [evmAddress("0x1234…"), evmAddress("0x5678…")],});
if (result.isErr()) {  return console.error(result.error);}
// Array<Erc20Amount | NativeAmount | Erc20BalanceError | NativeBalanceError>const balances = result.value;
```

This response differs slightly from others by providing a localized error for each balance that couldn’t be fetched. This enables more graceful error handling, allowing you to display some balances even if others fail.

```
for (let balance of balances) {  switch (balance.__typename) {    case "Erc20Amount":      console.log(`${balance.value} ${balance.asset.symbol}`);      break;
    case "NativeAmount":      console.log(`${balance.value} ${balance.asset.symbol}`);
    case "Erc20BalanceError":    case "NativeBalanceError":      console.error(balance.reason);  }}
```

## Fiat On-Ramps

Integrate fiat on-ramps into your app to allow users to deposit funds into their Lens Account using a debit or credit card. This can be achieved with [thirdweb Pay](https://portal.thirdweb.com/connect/pay/overview).

![](https://lens.xyz/docs/illustrations/thirdweb-pay.png)

The following procedure lays a foundation for integrating fiat on-ramps into your app.

Due to the absence of liquidity and swapping routes, this solution is fully
testable only on the Lens Mainnet.

1

### Get Your Client ID

First, log in to the [thirdweb dashboard](https://thirdweb.com/team). Navigate to the _Settings_ page and create an API key to get your Client ID.

2

### Configure thirdweb SDK

Next, install the thirdweb SDK.

```
npm install thirdweb
```

And, wrap your app with the <ThirdwebProvider> component as follows.

```
import { ThirdwebProvider } from "thirdweb/react";
export default function App() {  return <ThirdwebProvider>{/* Your app code here */}</ThirdwebProvider>;}
```

3

### Create a thirdweb Client

Create a thirdweb client using your Client ID.

```
import { createThirdwebClient } from "thirdweb";
export const client = createThirdwebClient({  clientId: "<your_client_id>",});
```

4

### The PayEmbed Widget

Finally, integrate the PayEmbed widget into your app to allow users to deposit funds using fiat on-ramps.

```
import { defineChain, NATIVE_TOKEN_ADDRESS } from "thirdweb";import { PayEmbed } from "thirdweb/react";
import { client } from "./thirdweb";
const lensChain = defineChain({ id: 232 });
// …
<PayEmbed  client={client}  payOptions={{    mode: "direct_payment",    metadata: {      name: 'Get GHO on Lens Chain',    }    buyWithFiat: {      preferredProvider: "COINBASE",
      // enable/disable test mode      testMode: true,    },    buyWithCrypto: {      // enable/disable test mode      testMode: true,    },    paymentInfo: {      chain: lensChain,
      // amount of token to buy      amount: "5",
      // Lens Account address      sellerAddress: "0x1234…",
      token: {        address: NATIVE_TOKEN_ADDRESS,        name: "GHO",        symbol: "GHO",        icon: "https://explorer.lens.xyz/images/gho.png",      },    },    onPurchaseSuccess: (purchase) => {      console.log("Purchase success", purchase);    },  }}/>;
```

Use the paymentInfo.sellerAddress to specify the Lens Account address to top
up. The integration suggested here is known as [Commerce\\
payment](https://playground.thirdweb.com/connect/pay/commerce), hence the term
_seller_ for the address receiving the tokens.

### Wallet Adapters

To prevent the need to reconnect the wallet when using the PayEmbed widget, you can utilize the wallet adapter for your chosen library.

- Viem
- Ethers

```
import { createThirdwebClient } from "thirdweb";import { viemAdapter } from "thirdweb/adapters/viem";import { ethereum } from "thirdweb/chains";import { type Address, createWalletClient, custom } from "viem";
import { walletClient } from "./wallet";
export const thirdwebWallet = await viemAdapter.wallet.fromViem({  walletClient: walletClient,});
export const client = createThirdwebClient({  clientId: "<your_client_id>",});
```

If you encounter a TypeScript error while assigning the WalletClient instance to the thirdweb viem adapter, it is likely due to a version mismatch between the viem version you have installed and the version used in the thirdweb SDK.

```
export const thirdwebWallet = await viemAdapter.wallet.fromViem({  walletClient: walletClient,});
```

To fix this, you can force the viem version in your package.json file according to the package manager you are using.

```
{  "dependencies": {    "thirdweb": "^5.89.0",    "viem": "^2.21.55"  },  "overrides": {    "viem": "^2.21.55"  }}
```

Then, run the following line before embedding the PayEmbed widget.

```
await thirdwebWallet.connect({ client });
```

And pass the thirdweb wallet to the PayEmbed widget.

```
import { thirdwebWallet } from "./thirdweb";
// …
<PayEmbed  activeWallet={thirdwebWallet}  client={client}  // …/>;
```

That's it—this will make the PayEmbed widget render without displaying a _Connect_ button.

## Deposit Funds

Account Owners and Account Managers can deposit funds into their Lens Accounts. To deposit funds, follow these steps.

You MUST be authenticated as the Account Owner or Account Manager to deposit
funds into the authenticated Lens Account.

1

### Prepare the Request

First, specify the amount to deposit.

- TypeScript
- GraphQL
- React

Use the deposit action to prepate the transaction request.

```
import { bigDecimal } from "@lens-protocol/client";import { deposit } from "@lens-protocol/client/action";
const result = await deposit(sessionClient, {  native: bigDecimal(42.5),});
```

2

### Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await withdraw(sessionClient, {  // …}).andThen(handleOperationWith(walletClient));
```

Unlike most other transactions, there is no need to wait for the transaction
to be indexed.

That's it—you can now use the funds in the Lens Account for collecting, tipping, and any other action or rule that requires funds.

## Wrapped GHO

Lens Chain uses **GHO** as its native gas token on mainnet and **GRASS** on testnet. If you need **Wrapped GHO (WGHO)**—or **Wrapped GRASS (WGRASS)** on testnet—to collect a publication in this currency or to tip someone, you can wrap the GHO or GRASS held in your Lens Account.

### Wrap GHO

To wrap tokens, follow these steps.

You MUST be authenticated as the Account Owner or Account Manager to be able
to wrap **GHO**—or \*\*GRASS on testnet—held in your Lens Account.

1

#### Prepare the Request

First, specify the amount to wrap.

- TypeScript
- GraphQL
- React

Use the wrapTokens action to prepate the transaction request.

```
import { bigDecimal } from "@lens-protocol/client";import { wrapTokens } from "@lens-protocol/client/action";
const result = await wrapTokens(sessionClient, {  amount: bigDecimal(42.5),});
```

2

#### Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await await wrapTokens(sessionClient, {  amount: bigDecimal(42.5),}).andThen(handleOperationWith(walletClient));
```

Unlike most other transactions, there is no need to wait for the transaction
to be indexed.

That's it—wrapped tokens are now in the Lens Account.

### Unwrap GHO

To unwrap tokens, follow these steps.

You MUST be authenticated as the Account Owner or Account Manager to be able
to unwrap WGHO or WGRASS held in your Lens Account.

1

#### Prepare the Request

First, specify the amount to unwrap.

- TypeScript
- GraphQL
- React

Use the unwrapTokens action to prepare the transaction request.

```
import { bigDecimal } from "@lens-protocol/client";import { unwrapTokens } from "@lens-protocol/client/action";
const result = await unwrapTokens(sessionClient, {  amount: bigDecimal(42.5),});
```

2

#### Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await unwrapTokens(sessionClient, {  // …}).andThen(handleOperationWith(walletClient));
```

Unlike most other transactions, there is no need to wait for the transaction
to be indexed.

That's it—unwrapped tokens are now in the Lens Account.

## Withdraw Funds

Account Owners can withdraw funds from their Lens Accounts. Account Managers can also withdraw funds from an account they manage, provided they have the canTransferTokens and/or canTransferNative permissions. See the [Account Manager](https://lens.xyz/docs/protocol/accounts/manager#add-account-managers) guide for more information.

To withdraw funds from a Lens Account, follow these steps.

You MUST be authenticated as the Account Owner or Account Manager with the
necessary permissions of the Lens Account you intend to withdraw funds from.

1

### Prepare the Request

First, specify the amount to withdraw and the destination address.

- TypeScript
- GraphQL
- React

Use the withdraw action to prepate the transaction request.

```
import { bigDecimal } from "@lens-protocol/client";import { withdraw } from "@lens-protocol/client/action";
const result = await withdraw(sessionClient, {  native: bigDecimal(42.5),});
```

2

### Handle Result

- TypeScript
- GraphQL
- React

Then, handle the result using the adapter for the library of your choice:

```
import { handleOperationWith } from "@lens-protocol/client/viem";
// …
const result = await withdraw(sessionClient, {  // …}).andThen(handleOperationWith(walletClient));
```

Unlike most other transactions, there is no need to wait for the transaction
to be indexed.

That's it—funds are now in the wallet address.

[Previous\\
\\
**Account Actions**](https://lens.xyz/docs/protocol/accounts/actions) [Next\\
\\
**Notifications**](https://lens.xyz/docs/protocol/accounts/notifications)
